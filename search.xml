<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树--非递归遍历</title>
      <link href="/2019/11/15/er-cha-shu-fei-di-gui-bian-li/"/>
      <url>/2019/11/15/er-cha-shu-fei-di-gui-bian-li/</url>
      
        <content type="html"><![CDATA[<p>前面讲了二叉树的递归遍历,今天来说说非递归遍历</p><h3 id="头文件准备"><a href="#头文件准备" class="headerlink" title="头文件准备"></a>头文件准备</h3><blockquote><p>如果你不清楚下面头文件请移步，<a href="http://blog.xunanmu.com/2019/11/02/feng-zhuang-stack/" target="_blank" rel="noopener">《C语言封装stack》</a>，<a href="http://blog.xunanmu.com/2019/11/03/feng-zhuang-queue/" target="_blank" rel="noopener">《C语言封装Queue》</a></p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Stack.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Queue.h"</span></span><span class="token macro property">#<span class="token directive keyword">define</span> true  (char)1</span><span class="token macro property">#<span class="token directive keyword">define</span> false (char)0</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> Status<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BinaryTree <span class="token punctuation">{</span>    <span class="token keyword">char</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> BinaryTree <span class="token operator">*</span>leftChild<span class="token punctuation">;</span>    <span class="token keyword">struct</span> BinaryTree <span class="token operator">*</span>rightChild<span class="token punctuation">;</span><span class="token punctuation">}</span> binaryTree_size<span class="token punctuation">,</span> <span class="token operator">*</span>BinaryTree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><blockquote><p>1.方法一是常规思路，是按照前序先访问<code>父节点</code> 把他压入stack，在访问其左孩子，直到左孩子为Null把其出栈访问他的右孩子；继续重复操作访问其左孩子，直到访问完所有节点。</p></blockquote><pre class="line-numbers language-c"><code class="language-c">   <span class="token keyword">void</span> <span class="token function">preOrderTraversal_1</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>           <span class="token keyword">return</span><span class="token punctuation">;</span>       Stack s <span class="token operator">=</span> <span class="token function">initStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">do</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>               s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>               T <span class="token operator">=</span> T<span class="token operator">-></span>leftChild<span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span> <span class="token punctuation">{</span>               T <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>               s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>               T <span class="token operator">=</span> T<span class="token operator">-></span>rightChild<span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">||</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>2.方法2思路不管左右是否为空通通以<code>满二叉</code>压入栈，首先把根节点压入栈，然后弹出根节点判断他是不是空节点如果是空就不访问，栈空直接循环结束；如果不为空就访问他，并先压入右孩子再压左孩子，有的为什么先压右孩子？。。。。。。因为熟悉栈的同学都知道的栈是先压后出的。</p></blockquote><pre class="line-numbers language-c"><code class="language-c">   <span class="token keyword">void</span> <span class="token function">preOrderTraversal_2</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//习惯性敲为Null返回条件，这个判断可以删掉的</span>           <span class="token keyword">return</span><span class="token punctuation">;</span>         Stack s <span class="token operator">=</span> <span class="token function">initStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">do</span> <span class="token punctuation">{</span>           T <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>           s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>               s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>               s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>3.第三个方法和第一个方法刚思路类似只不过处理节点刚好相反。我们可以每次访问该节点的时候把他的右孩子先压入，然后再访问他左孩子，直到他左孩子为Null时弹出他的右孩子继续重复操作访问完所有节点。</p></blockquote><pre class="line-numbers language-c"><code class="language-c">   <span class="token keyword">void</span> <span class="token function">preOrderTraversal_3</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>           <span class="token keyword">return</span><span class="token punctuation">;</span>       Stack s <span class="token operator">=</span> <span class="token function">initStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span>               s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span>               T <span class="token operator">=</span> T<span class="token operator">-></span>leftChild<span class="token punctuation">;</span>           <span class="token keyword">else</span>               T <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><blockquote><p>思路很简单：他和<code>前序的方法一</code>结构几乎一样，按照中序思路先访问左孩子，那么我们就把左孩子一直压，直到他为左孩子为空时，把他出栈访问，然后访问他右孩子继续压他右孩子的左孩子；如果没有右孩子就出栈继续重复操作。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">inOrderTraversal</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    Stack s <span class="token operator">=</span> <span class="token function">initStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>            T <span class="token operator">=</span> T<span class="token operator">-></span>leftChild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            T <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            T <span class="token operator">=</span> T<span class="token operator">-></span>rightChild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">||</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注释</strong>：你们也可以仿照<code>前序的方法2和方法3</code>来写，这里我就不重复说了，他们结构几乎都一样，只是细节有点小差别。</p></blockquote><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><blockquote><p>1.后序遍历时由于访问完左右子树后才能访问根结点，因此需要将根结点在栈内保留到左右子树被访问后，才能访问。我们这里可以利用<code>stack的思路</code>，在父节点这先不访问，把他压入栈，如果他的右孩子不为Null压入栈一直压右孩子，否则压入左孩子。这里单栈不好操作，我们用<code>双栈遍历后序</code>，具体操作，一个栈访问，一个栈压入，栈<code>S1</code>先压入父节点，然后判断左右孩子不为Null压入左右孩子；另一个栈<code>S2</code>压入父节点，然后<code>S1</code>把栈顶弹出（<strong>注意</strong>：这里<code>栈top</code>已经不是父节点了而是他的子节点），继续重复操作。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">postOrderTraversal_1</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    Stack s1 <span class="token operator">=</span> <span class="token function">initStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack s2 <span class="token operator">=</span> <span class="token function">initStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        s1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span>            s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span>            s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>        s2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s2<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>        T <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        T <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>        s2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>2.首先将整棵二叉树的根结点入栈。取栈顶结点，在这里我们需要在定义一个变量pre代表前面一个访问的结点，若其不存在左右孩子，或存在左孩子或右孩子，但其左子结点和右子结点都被访问过了，则访问此结点，并将他从栈中弹出。若非上述两种情况，则将其的右子结点和左子结点依次入栈。重复上述操作，直到栈为空，遍历结束。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">postOrderTraversal_2</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    Stack s <span class="token operator">=</span> <span class="token function">initStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BinaryTree pre<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>leftChild<span class="token operator">==</span>T<span class="token operator">-></span>rightChild<span class="token operator">||</span>pre<span class="token operator">==</span>T<span class="token operator">-></span>rightChild<span class="token operator">||</span>pre<span class="token operator">==</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            pre<span class="token operator">=</span>T<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span>                s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span>                s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        T<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>3.思路和方法2类似：需要将根结点在栈内保留到左右子树被访问后，我们先一直压他的左孩子，到尾时就访问此节点，然后访问他的右子树。<strong>注意：我们同样需要在定义一个变量pre代表前面一个访问的结点，当pre与栈顶结点的右子树结点相同时，则不再将右子树结点压入栈中</strong>否则就呵呵哒了！原因就是<br>：当右子树弹出后遇到根结点又会将右子树结点压入栈中，造成死循环。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">postOrderTraversal_3</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    Stack s <span class="token operator">=</span> <span class="token function">initStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BinaryTree pre<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>BinaryTree<span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>leftChild<span class="token punctuation">)</span><span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">(</span>BinaryTree<span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>BinaryTree<span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>rightChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">||</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>BinaryTree<span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>rightChild<span class="token operator">==</span>pre<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>BinaryTree<span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                pre<span class="token operator">=</span><span class="token punctuation">(</span>BinaryTree<span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>BinaryTree<span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>rightChild<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">(</span>BinaryTree<span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><strong>代码格式，咳咳咳！我太懒了不想书写了，可能C语言看着有点怪，但是其他语言看着就很简单了，例如c艹</strong></p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><blockquote><p>层次就非常简单了，利用queue操作，我们先把根入队，然后把他出队访问，判断他左右孩子不为Null入队，然后重复操作。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">levelTraversal</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    Queue q<span class="token operator">=</span><span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        T<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">getfront</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span>            q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span>            q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有同学问为什么要用非递归方法，递归明显代码更简洁清晰，这个嘛？那些高效的算法代码几乎都很目涩，看着脑壳大，但是人家算100000！只要0.02s。。。我们0.02s估计连1000！阶乘也没有算出来。下面👇🏻给大家推荐一篇文章<a href="http://blog.csdn.net/laoyang360/article/details/7855860" target="_blank" rel="noopener">深究递归和迭代的区别、联系、优缺点及实例对比</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树--递归遍历</title>
      <link href="/2019/11/15/er-cha-shu-di-gui-bian-li/"/>
      <url>/2019/11/15/er-cha-shu-di-gui-bian-li/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>前面我们讲了四种二叉树遍历方式,本文主要是以递归方式遍历二叉树,非递归方式请看下一篇.</p></blockquote><pre><code>                 A               /   \              B     C             / \   / \            D   E F   G           / \       /          H   I     J</code></pre><p><strong>此树遍历有</strong></p><ol><li><p>前序是 <code>父节点-&gt;左子树-&gt;右子树</code>, A B D H I E C F G J</p></li><li><p>中序是 <code>左子树-&gt;父节点-&gt;右子树</code>, H D I B E A F C J G</p></li><li><p>后序是 <code>左子树-&gt;右子树-&gt;父节点</code>, H I D E B F J G C A</p></li><li><p>层次是 <code>自上而下一层层访问节点</code>, A B C D E F G H I J</p><p>层次另外一种遍历方式: A C B D E F G J I H, <code>Z型遍历</code></p></li></ol><h3 id="数组创建二叉树"><a href="#数组创建二叉树" class="headerlink" title="数组创建二叉树"></a>数组创建二叉树</h3><blockquote><p>遍历前我们先说说如何简单的建立一颗二叉树.</p></blockquote><h4 id="二叉树节点定义"><a href="#二叉树节点定义" class="headerlink" title="二叉树节点定义"></a>二叉树节点定义</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*由于c语言没有bool型我们宏定义bool*/</span><span class="token macro property">#<span class="token directive keyword">define</span> true  (char)1</span><span class="token macro property">#<span class="token directive keyword">define</span> false (char)0</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> Status<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*这里默认数据类型是字符*/</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> DataType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BinaryTree <span class="token punctuation">{</span>    DataType data<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//数据域</span>    <span class="token keyword">struct</span> BinaryTree <span class="token operator">*</span>leftChild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左孩子指针</span>    <span class="token keyword">struct</span> BinaryTree <span class="token operator">*</span>rightChild<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右孩子指针</span><span class="token punctuation">}</span>binaryTree_size<span class="token punctuation">,</span><span class="token operator">*</span>BinaryTree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建思路"><a href="#创建思路" class="headerlink" title="创建思路"></a>创建思路</h4><ol><li><p>我们用数组思路,来建立一颗二叉树,请看下表二叉树和地址关系</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td><td align="center">E</td><td align="center">F</td><td align="center">G</td><td align="center">H</td><td align="center">I</td><td align="center">J</td></tr></tbody></table><p>Treeroot地址为数组第一个地址,也就是0(A),;</p><p>那么他有左孩子B,那么利用<code>realloc()</code>函数申请地址使<code>T[0]-&gt;leftChild=T[1]</code>,</p><p>他还有右孩子C接下来就是申请右孩子的内存使<code>T[0]-&gt;rightChild=T[2]</code>,</p><p>接着就是B继续A的操作,<code>T[1]-&gt;leftChild=T[3]</code>,<code>T[1]-&gt;rightChild=T[4]</code>,</p><p>当我们到达E时,他没有左右孩子,就<code>T[4]-&gt;leftChild=NULL</code>,<code>T[4]-&gt;rightChild=nULL</code>,</p><p>接下F重复操作;</p><p>最后到 J 时,这个节点时如何结束呢?</p><p>不要慌,我们就判断一下<code>T[10]</code>在不在这棵树中,哦不,T[10]是肯定不在的.因为T[9]后面已经没有任何节点了,所以就判断 <em>所取<code>父节点P</code>大于Tree数组长度时就退出</em>.</p></li><li><p>代码实现</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> c<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">'#'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span>Status <span class="token function">levelCreat</span><span class="token punctuation">(</span>BinaryTree <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>root<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true">//判断根节点是否存在,存在返回错误</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    DataType dataType <span class="token operator">=</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建接收数据的变量,数据错误return NULL</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dataType<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true">//如果第一个数据错误,不建树返回错误</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    BinaryTree T<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//创建变量代替root</span>    T <span class="token operator">=</span> <span class="token punctuation">(</span>BinaryTree <span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>binaryTree_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给root分配内存</span>    <span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">-></span>data <span class="token operator">=</span> dataType<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//把数据赋值给root</span>    BinaryTree p <span class="token operator">=</span> T<span class="token punctuation">,</span> new <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//创建临时Node*指针</span>    <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//创建数组计树器,并初始0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">&lt;=</span><span class="token operator">&amp;</span>T<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//如果父节点超出数组长度,即节点p不存在</span>    <span class="token punctuation">{</span>        dataType<span class="token operator">=</span><span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//获取数据,输入错误为NULL</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dataType<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token operator">++</span>n<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//增加一个节点计数,n代表当前new地址</span>            T<span class="token operator">=</span><span class="token function">realloc</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>binaryTree_size<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            new<span class="token operator">=</span><span class="token operator">&amp;</span>T<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//new接收新节点地址</span>            new<span class="token operator">-></span>data<span class="token operator">=</span>dataType<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p<span class="token operator">-></span>leftChild<span class="token operator">=</span>new<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//左孩子接收节点地址</span>        new<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//把nwe指针恢复Null</span>        dataType<span class="token operator">=</span><span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dataType<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token operator">++</span>n<span class="token punctuation">;</span>            T<span class="token operator">=</span><span class="token function">realloc</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>binaryTree_size<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            new<span class="token operator">=</span><span class="token operator">&amp;</span>T<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            new<span class="token operator">-></span>data<span class="token operator">=</span>dataType<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p<span class="token operator">-></span>rightChild<span class="token operator">=</span>new<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//右孩子接收节点地址</span>        new<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>        p<span class="token operator">=</span><span class="token operator">&amp;</span>T<span class="token punctuation">[</span><span class="token operator">++</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//把父节点赋值p,index表示当前父节点</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>root<span class="token operator">=</span>T<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以把上面重复的代码优化一下,设置一个flag=0.利用flag=~flag和do-while特性.</p><pre class="line-numbers language-c"><code class="language-c">Status <span class="token function">levelCreat</span><span class="token punctuation">(</span>BinaryTree <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>root<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true">//判断根节点是否存在,存在返回错误</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    DataType dataType <span class="token operator">=</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建接收数据的指针,数据错误return NULL</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dataType<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true">//如果第一个数据错误,不建树返回错误</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    BinaryTree T<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//创建变量代替root</span>    T <span class="token operator">=</span> <span class="token punctuation">(</span>BinaryTree <span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>binaryTree_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给root分配内存s</span>    <span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">-></span>data <span class="token operator">=</span> dataType<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//把数据赋值给root</span>    BinaryTree p <span class="token operator">=</span> T<span class="token punctuation">,</span> new <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//创建临时Node*指针</span>    <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//创建数组计树器,并初始0</span>    <span class="token keyword">char</span> flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//创建flag,优化重复代码</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">&lt;=</span><span class="token operator">&amp;</span>T<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//如果父节点超出数组长度,即节点p不存在</span>    <span class="token punctuation">{</span>        <span class="token keyword">do</span><span class="token punctuation">{</span>            dataType<span class="token operator">=</span><span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//获取数据,输入错误为NULL</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dataType<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token operator">++</span>n<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//增加一个节点计数,n代表当前new地址</span>                T<span class="token operator">=</span><span class="token function">realloc</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>binaryTree_size<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                new<span class="token operator">=</span><span class="token operator">&amp;</span>T<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//new接收新节点地址</span>                new<span class="token operator">-></span>data<span class="token operator">=</span>dataType<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//把数据赋值给new</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">//flag判断左右孩子</span>                p<span class="token operator">-></span>leftChild<span class="token operator">=</span>new<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//左孩子接收节点地址</span>            <span class="token keyword">else</span>                p<span class="token operator">-></span>rightChild<span class="token operator">=</span>new<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//右孩子接收节点地址</span>            new<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//把nwe指针恢复Null</span>            flag<span class="token operator">=</span><span class="token operator">~</span>flag<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//flag取反很重要,</span>        <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//flag判断是否继续循环</span>        p<span class="token operator">=</span><span class="token operator">&amp;</span>T<span class="token punctuation">[</span><span class="token operator">++</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//把父节点赋值p,index表示当前父节点</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>root<span class="token operator">=</span>T<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><blockquote><p>递归思想：通俗的说就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">preOrderTraversal</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/*显示结点数据，可以更改为其他对结点操作*/</span>    <span class="token function">preOrderTraversal</span><span class="token punctuation">(</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*再先序遍历左子树*/</span>    <span class="token function">preOrderTraversal</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*最后先序遍历右子树*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><blockquote><p>递归思想：就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">inOrderTraversal</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">inOrderTraversal</span><span class="token punctuation">(</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*中序遍历左子树*/</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*显示结点数据，可以更改为其他对结点操作*/</span>    <span class="token function">inOrderTraversal</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*最后中序遍历右子树*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><blockquote><p>递归思想：就是从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">postOrderTraversal</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">postOrderTraversal</span><span class="token punctuation">(</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*先后序遍历左子树*/</span>    <span class="token function">postOrderTraversal</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*再后续遍历右子树*/</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*显示结点数据，可以更改为其他对结点操作*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><blockquote><p>层次还用写吗?直接循环数组就结束了:happy:,hh开玩笑的,本文数组建立有点特殊可以直接循环遍历,但是一般二叉树都是二叉链式结构.我这里说一下递归层次遍历通用办法,比前面三种稍微复杂.</p></blockquote><ol><li><p>我们要知道树的深度才能遍历,也就是树的层数,下面是用递归求深度算法：<br>我们可以从根节点即左右子树来理解二叉树的深度。对于任意一棵非空二叉树，有如下四种情况：<br>（1）如果一颗树只有一个节点，它的深度是1；<br>（2）如果根节点只有左子树而没有右子树，那么二叉树的深度应该是其左子树的深度加1；<br>（3）如果根节点只有右子树而没有左子树，那么二叉树的深度应该是其右树的深度加1；<br>（4）如果根节点既有左子树又有右子树，那么二叉树的深度应该是其左右子树的深度较大值加1；</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">treeDepth</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token function">treeDepth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token function">treeDepth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> leftDepth<span class="token operator">></span>rightDepth<span class="token operator">?</span> <span class="token punctuation">(</span>leftDepth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>rightDepth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><blockquote><p>递归思想：先一层一层的找，每层从根节点递归找左右子树的末端</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">printLevelNode</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>level<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//如果是层数是1也就是树的最尾端打印</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printLevelNode</span><span class="token punctuation">(</span>T<span class="token operator">-></span>leftChild<span class="token punctuation">,</span>level<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//找左子树端尾节点</span>    <span class="token function">printLevelNode</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rightChild<span class="token punctuation">,</span>level<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//找右子树端尾节点</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">levelTraversal</span><span class="token punctuation">(</span>BinaryTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token function">treeDepth</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//获取树的深度</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>depth<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//遍历每一层节点</span>        <span class="token function">printLevelNode</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>好了写到这了,对了二叉树还有其他方法遍历,例如<code>垂序遍历</code>类似广义表遍历不过他是左右对称遍历.还有他们的非递归方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树--概念篇</title>
      <link href="/2019/11/04/er-cha-shu-gai-nian-pian/"/>
      <url>/2019/11/04/er-cha-shu-gai-nian-pian/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>写这个主要是以后我考研可能要用,死记一下这个概念.</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p><strong>二叉树</strong>是<code>n(n&gt;=0)</code>个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。<br>下面展示了一棵普通二叉树：</p></blockquote><pre><code>                 A               /   \              B     C             / \   / \            D   E F   G           / \       /          H   I     J</code></pre><h4 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h4><p>由二叉树定义以及图示分析得出二叉树有以下特点：</p><ol><li>每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</li></ol><h4 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h4><ol><li><p>在二叉树的第i层上最多有2^i-1^ 个节点 。（i&gt;=1）</p></li><li><p>二叉树中如果深度为k,那么最多有2^k-1^个节点。(k&gt;=1）</p></li><li><p>n<del>0</del>=n<del>2</del>+1  n<del>0</del>表示度数为0的节点数，n<del>2</del>表示度数为2的节点数。</p></li><li><p>在完全二叉树中，具有n个节点的完全二叉树的深度为[log<del>2</del>^n^]+1，其中[log<del>2</del>^n^]是向下取整。</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：</p><ul><li>若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;</li><li>若 2i&gt;n，则该结点无左孩子，  否则，编号为 2i 的结点为其左孩子结点；</li><li>若 2i+1&gt;n，则该结点无右孩子结点，  否则，编号为2i+1 的结点为其右孩子结点。</li></ul></li></ol><h4 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h4><p><strong>斜树</strong>：所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><ol><li><p><strong>左斜树</strong></p><pre><code>                        A                       /                      B                     /                    C                   /                  D</code></pre></li><li><p><strong>右斜树</strong></p><pre><code>              A               \                B                 \                  C</code></pre></li></ol><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p><strong>满二叉树</strong>：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。<br>    满二叉树的特点有：</p><ol><li><p>叶子只能出现在最下一层。出现在其它层就不可能达成平衡。</p></li><li><p>非叶子结点的度一定是2。</p></li><li><p>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</p></li></ol><pre><code>                 A               /   \              B     C             / \   / \            D   E F   G</code></pre><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><strong>完全二叉树</strong>：对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。<br> 下面展示一棵完全二叉树:</p><pre><code>                 A               /   \              B     C             / \   /             D   E F   </code></pre><p><strong>特点</strong>：</p><ol><li><p>叶子结点只能出现在最下层和次下层。</p></li><li><p>最下层的叶子结点集中在树的左部。</p></li><li><p>倒数第二层若存在叶子结点，一定在右部连续位置。</p></li><li><p>如果结点度为1，则该结点只有左孩子，即没有右子树。</p></li><li><p>同样结点数目的二叉树，完全二叉树深度最小。</p></li></ol><p><strong>注</strong>：<code>满二叉树一定是完全二叉树，但反过来不一定成立。</code></p><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><blockquote><p>二叉树的遍历一个重点考查的知识点</p></blockquote><p><strong>二叉树的遍历</strong>是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。<br> 二叉树的访问次序可以分为四种：</p><pre class="line-numbers language-JAVA"><code class="language-JAVA">/*               A               /   \              B     C             / \   / \            D   E F   G           / \       /          H   I     J *//** * 前序是 父节点->左子树->右子树, A B D H I E C F G J * 中序是 左子树->父节点->右子树, H D I B E A F C J G * 后序是 左子树->右子树->父节点, H I D E B F J G C A * 层次是 自上而下一层层访问节点, A B C D E F G H I J * */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="遍历常考考点"><a href="#遍历常考考点" class="headerlink" title="遍历常考考点"></a>遍历常考考点</h4><blockquote><p>对于二叉树的遍历有一类典型题型。</p></blockquote><ol><li><p>已知前序遍历序列和中序遍历序列，确定一棵二叉树。</p></li><li><p>已知后序遍历序列和中序遍历序列，确定一棵二叉树。</p><p><strong>注</strong>：已知前序遍历序列和后序遍历序列，不可以唯一确定一棵二叉树。</p></li></ol><p>二叉树基本概念写完。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言封装queue</title>
      <link href="/2019/11/03/feng-zhuang-queue/"/>
      <url>/2019/11/03/feng-zhuang-queue/</url>
      
        <content type="html"><![CDATA[<h2 id="封装Queue思路"><a href="#封装Queue思路" class="headerlink" title="封装Queue思路"></a>封装Queue思路</h2><blockquote><p>这个思路和前面<a href="http://blog.xunanmu.com/2019/11/02/feng-zhuang-stack/#toc-heading-1" target="_blank" rel="noopener">stack</a>封装差不多,我说说细节吧。</p></blockquote><ul><li><code>enqueue()</code>:  L.getTail()</li><li><code>dequeue()</code>:  L.removeHead()</li><li><code>front()</code>:  L.getHead()</li><li><code>empty()</code>:  L.emprt()</li><li><code>clean()</code>:  L.clean()</li></ul><p><strong>还有其他操作你可以自己添加, 比如遍历队列, 或者把这个队列封装成双向队列等</strong></p><h2 id="Queue函数实现"><a href="#Queue函数实现" class="headerlink" title="Queue函数实现"></a>Queue函数实现</h2><h3 id="Queue-h头文件"><a href="#Queue-h头文件" class="headerlink" title="Queue.h头文件"></a>Queue.h头文件</h3><blockquote><p>我们同样定义头文件,对于头文件知识可以翻前面前面<a href="http://blog.xunanmu.com/2019/11/01/lian-biao-feng-zhuang/#toc-heading-2" target="_blank" rel="noopener">&lt;&lt;C语言封装链表&gt;&gt;</a>这篇。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by 徐南木 on 2019/11/3.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> DATASTRUCT_QUEUE_H</span><span class="token macro property">#<span class="token directive keyword">define</span> DATASTRUCT_QUEUE_H</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LinkedList.h"</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Queue Queue<span class="token punctuation">;</span><span class="token keyword">struct</span> Queue<span class="token punctuation">{</span>    LinkedList L<span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>enqueue<span class="token punctuation">)</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">,</span>DataType<span class="token operator">*</span> dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>dequeue<span class="token punctuation">)</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>length<span class="token punctuation">)</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>empty<span class="token punctuation">)</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>clean<span class="token punctuation">)</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>    DataType<span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>front<span class="token punctuation">)</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Queue <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">//DATASTRUCT_QUEUE_H</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Queue-c函数文件"><a href="#Queue-c函数文件" class="headerlink" title="Queue.c函数文件"></a>Queue.c函数文件</h3><blockquote><p>这个和前面stack是一样的我直接贴代码。对于双端队列你可以自行添加</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by 徐南木 on 2019/11/3.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Queue.h"</span></span><span class="token keyword">static</span> Status <span class="token function">enqueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">,</span>DataType<span class="token operator">*</span> dataType<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Q<span class="token operator">-></span>L<span class="token punctuation">.</span><span class="token function">addTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token operator">-></span>L<span class="token punctuation">,</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">dequeue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Q<span class="token operator">-></span>L<span class="token punctuation">.</span><span class="token function">removeHead</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token operator">-></span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">length</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Q<span class="token operator">-></span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">empty</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Q<span class="token operator">-></span>L<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">clean</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Q<span class="token operator">-></span>L<span class="token punctuation">.</span><span class="token function">clean</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token operator">-></span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> DataType<span class="token operator">*</span> <span class="token function">getfront</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>Q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Q<span class="token operator">-></span>L<span class="token punctuation">.</span><span class="token function">getHead</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token operator">-></span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Queue <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Queue Q<span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>L<span class="token operator">=</span><span class="token function">initLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>enqueue<span class="token operator">=</span>enqueue<span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>dequeue<span class="token operator">=</span>dequeue<span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>length<span class="token operator">=</span>length<span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>empty<span class="token operator">=</span>empty<span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>getfront<span class="token operator">=</span>getfront<span class="token punctuation">;</span>    <span class="token keyword">return</span> Q<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>现在我们把队列也封装了，下面构造二叉树我们可以直接使用它们了:happy:</strong></p><p><strong>如果有错,请联系告诉我,谢谢了!</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言封装stack</title>
      <link href="/2019/11/02/feng-zhuang-stack/"/>
      <url>/2019/11/02/feng-zhuang-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="封装stack基本思路"><a href="#封装stack基本思路" class="headerlink" title="封装stack基本思路"></a>封装stack基本思路</h2><blockquote><p>我们上一篇已经把链表封装了,现在封装stack基本思路是内套一个链表,在写个stack结构体封装他的基本操作函数.</p></blockquote><ul><li><code>push()</code>:  可以利用LinkedList的<code>addHead()</code>函数.</li><li><code>pop()</code>:  用<code>L.remove()</code>函数.</li><li><code>top()</code>:  <code>L.getHead()</code>函数.  </li><li><code>clean()</code>:  <code>L.clean()</code>函数.</li><li><code>length()</code>:  你也可以把设置成一个成员,我这里把他设置成一个函数.</li><li><code>empty()</code>:  可以用<code>L.length</code>成员判断,你也可以把链表<code>empty()</code>封装,前面我没有封装链表判空操作函数.         </li></ul><h2 id="Stack函数实现"><a href="#Stack函数实现" class="headerlink" title="Stack函数实现"></a>Stack函数实现</h2><h3 id="Stack-h头文件"><a href="#Stack-h头文件" class="headerlink" title="Stack.h头文件"></a>Stack.h头文件</h3><blockquote><p>同样我们先定义一个头文件,方便日后其他文件调用,由于前面一篇写了<code>LinkedList.h</code>类似的,这我就不啰嗦了,直接贴代码.</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by 徐南木 on 2019/11/2.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> DATASTRUCT_STACK_H</span><span class="token macro property">#<span class="token directive keyword">define</span> DATASTRUCT_STACK_H</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LinkedList.h"</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Stack<span class="token punctuation">{</span>    LinkedList L<span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>push<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Stack <span class="token operator">*</span>S<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>pop<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Stack <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>empty<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Stack <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>length<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Stack <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>clean<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Stack <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    DataType <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>top<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Stack <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Stack<span class="token punctuation">;</span>Stack <span class="token function">initStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">//DATASTRUCT_STACK_H</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Stack-c函数文件"><a href="#Stack-c函数文件" class="headerlink" title="Stack.c函数文件"></a>Stack.c函数文件</h3><blockquote><p>写<code>Stack</code>操作函数非常简单,你把前面<code>LinkedList</code>写得在完善一点,你甚至可以直接写个i<code>nitStack()</code>函数就行了.</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by 徐南木 on 2019/11/2.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Stack.h"</span></span><span class="token keyword">static</span> Status <span class="token function">push</span> <span class="token punctuation">(</span>Stack <span class="token operator">*</span>S<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> S<span class="token operator">-></span>L<span class="token punctuation">.</span><span class="token function">addHead</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token operator">-></span>L<span class="token punctuation">,</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">pop</span><span class="token punctuation">(</span>Stack <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> S<span class="token operator">-></span>L<span class="token punctuation">.</span><span class="token function">removeHead</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token operator">-></span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">empty</span><span class="token punctuation">(</span>Stack <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> S<span class="token operator">-></span>L<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">length</span><span class="token punctuation">(</span>Stack <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> S<span class="token operator">-></span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">clean</span><span class="token punctuation">(</span>Stack <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> S<span class="token operator">-></span>L<span class="token punctuation">.</span><span class="token function">clean</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token operator">-></span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> DataType <span class="token operator">*</span><span class="token function">top</span><span class="token punctuation">(</span>Stack <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> S<span class="token operator">-></span>L<span class="token punctuation">.</span><span class="token function">getHead</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token operator">-></span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Stack <span class="token function">initStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Stack S<span class="token punctuation">;</span>    S<span class="token punctuation">.</span>L<span class="token operator">=</span><span class="token function">initLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    S<span class="token punctuation">.</span>push<span class="token operator">=</span>push<span class="token punctuation">;</span>    S<span class="token punctuation">.</span>pop<span class="token operator">=</span>pop<span class="token punctuation">;</span>    S<span class="token punctuation">.</span>empty<span class="token operator">=</span>empty<span class="token punctuation">;</span>    S<span class="token punctuation">.</span>length<span class="token operator">=</span>length<span class="token punctuation">;</span>    S<span class="token punctuation">.</span>top<span class="token operator">=</span>top<span class="token punctuation">;</span>    <span class="token keyword">return</span> S<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>到此我们已经把<code>stack</code>封装好了,如果有错,请联系告诉我,谢谢了!</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言链表封装</title>
      <link href="/2019/11/01/lian-biao-feng-zhuang/"/>
      <url>/2019/11/01/lian-biao-feng-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="链表基本介绍"><a href="#链表基本介绍" class="headerlink" title="链表基本介绍"></a>链表基本介绍</h2><blockquote><p>我们都学过链表,单链表,循环链表,双向链表. 有没有想过把这些链表操作全部结合到一起呢?</p></blockquote><p>把他们的函数调用像调用成员那样,直接用<code>.</code>就可以操作. </p><p>废话不多说,由于C语言不像C++可以直接在结构体<code>struct</code>定义函数成员,但是C语言精髓<code>指针</code>操作可以做到. 下面我们利用C语言的函数指针达到封装效果.</p><h3 id="定义链表"><a href="#定义链表" class="headerlink" title="定义链表"></a>定义链表</h3><ol><li><p>首先我们选创建一个<code>LinkedList.h</code>头文件</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> DATASTRUCT_LINKEDLIST_H</span><span class="token macro property">#<span class="token directive keyword">define</span> DATASTRUCT_LINKEDLIST_H </span><span class="token comment" spellcheck="true">//定义宏,防止编译器重复编译</span><span class="token comment" spellcheck="true">//在宏中间编写代码</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span>   </span><span class="token comment" spellcheck="true">//申请节点,需要用的头文件</span><span class="token macro property">#<span class="token directive keyword">define</span> true  (char)1 </span><span class="token comment" spellcheck="true">//由于c没有bool型,我们自定义bool</span><span class="token macro property">#<span class="token directive keyword">define</span> false (char)0</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> Status<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> DataType<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽象数据类型</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">//</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>定义链表节点结构体,就是双向链表节点的结构体</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> LinkedListNode<span class="token punctuation">{</span>   <span class="token keyword">struct</span> LinkedListNode <span class="token operator">*</span>previous<span class="token punctuation">;</span>   <span class="token keyword">struct</span> LinkedListNode <span class="token operator">*</span>next<span class="token punctuation">;</span>   DataType <span class="token operator">*</span>dataType<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//抽象数据</span>  <span class="token punctuation">}</span>LinkedListNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>定义链表结构体</p><blockquote><p>想想需要哪些操作?</p></blockquote><ul><li><strong>链表长度:</strong> 我们把length定义int;</li><li><strong>获取节点:</strong> 我们把函数分成三个,一个头,一个尾,最后一个应该能随便访问任何一个位置</li><li><strong>增加节点:</strong> 同上面一样的操作,只不过我把随便增加节点函数命名插入<code>insert</code></li><li><strong>删除节点:</strong> 同上, 头尾移除命名为<code>remove</code>,能随便删除命为<code>delete</code></li><li><strong>遍历:</strong> 我们创建了链表,肯定得瞅一瞅,不过这个得结合<code>printData()</code>这个函数</li><li><strong>排序:</strong> 我们偶尔也要排排成绩嘛,:raised_hand_with_fingers_splayed: 我成绩一般都是前五(倒序排)</li><li><strong>清空:</strong> 链表数据没有用了我们就把他清空掉</li><li><strong>printData:</strong> 定义打印数据的接口,学生,教师,图书,物品每一种数据结构都不一样,这个需要重新定义</li><li><strong>freeData:</strong> 当你需要删除动态数据时候你需要重新定义,默认空函数;</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> LinkedList<span class="token punctuation">{</span>    LinkedListNode <span class="token operator">*</span>head<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>    DataType<span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>get<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    DataType<span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>getHead<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    DataType<span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>getTail<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>addHead<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>addTail<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>removeHead<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>removeTail<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>insert<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>delete<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>traversal<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>sort<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>clean<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>printData<span class="token punctuation">)</span><span class="token punctuation">(</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>freeData<span class="token punctuation">)</span><span class="token punctuation">(</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>LinkedList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结构体定义完了,我们需要初始化这些数据,接下来定义初始化函数(类似<code>new</code>这个操作,只不过我们是静态分配,我们也可以写成动态定义)</p><pre class="line-numbers language-c"><code class="language-c"> LinkedList <span class="token function">initLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><ol><li><p>我们创建一个<code>LinkedList.c</code> 文件</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LinkedList.h"</span></span><span class="token comment" spellcheck="true">//这个必须包含进去</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>*<em>相信你们都熟悉链表操作函数,在这里我要谈一下,咱们得把函数设置成<code>static</code>这个主要屏蔽外部文件访问这个函数,主要还是避免日后写了个重复函数名  *</em></p><blockquote><p>对了,前面忘说了,我们把这个链表设置有头节点的,方便操作.</p></blockquote></li></ol><h4 id="获取节点函数"><a href="#获取节点函数" class="headerlink" title="获取节点函数"></a><strong><em>获取节点函数</em></strong></h4><pre class="line-numbers language-c"><code class="language-c">   <span class="token keyword">static</span> DataType <span class="token operator">*</span><span class="token function">get</span><span class="token punctuation">(</span>LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>index<span class="token operator">></span>L<span class="token operator">-></span>length<span class="token operator">||</span>index<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> pos<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>       LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>L<span class="token operator">-></span>head<span class="token operator">&amp;&amp;</span>pos<span class="token operator">&lt;</span>index<span class="token punctuation">)</span>       <span class="token punctuation">{</span>           p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>           <span class="token operator">++</span>pos<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> p<span class="token operator">-></span>dataType<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">static</span> DataType <span class="token operator">*</span><span class="token function">getHead</span><span class="token punctuation">(</span>LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token operator">-></span>dataType<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">static</span> DataType <span class="token operator">*</span><span class="token function">getTail</span><span class="token punctuation">(</span>LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token operator">-></span>dataType<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="头尾加函数"><a href="#头尾加函数" class="headerlink" title="头尾加函数"></a><strong><em>头尾加函数</em></strong></h4><blockquote><p> 利用循环链表的特性,直接添加O(1)</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">addHead</span><span class="token punctuation">(</span>LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">{</span>    LinkedListNode <span class="token operator">*</span>new<span class="token operator">=</span><span class="token punctuation">(</span>LinkedListNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    new<span class="token operator">-></span>dataType<span class="token operator">=</span>dataType<span class="token punctuation">;</span>    new<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token punctuation">;</span>    new<span class="token operator">-></span>previous<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token operator">-></span>previous<span class="token operator">=</span>new<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token operator">=</span>new<span class="token punctuation">;</span>    <span class="token operator">++</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">addTail</span><span class="token punctuation">(</span>LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">{</span>    LinkedListNode <span class="token operator">*</span>new<span class="token operator">=</span><span class="token punctuation">(</span>LinkedListNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    new<span class="token operator">-></span>dataType<span class="token operator">=</span>dataType<span class="token punctuation">;</span>    new<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    new<span class="token operator">-></span>previous<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token operator">-></span>next<span class="token operator">=</span>new<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token operator">=</span>new<span class="token punctuation">;</span>    <span class="token operator">++</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="头尾删除函数"><a href="#头尾删除函数" class="headerlink" title="头尾删除函数"></a>头尾删除函数</h4><blockquote><p>利用循环链表的特性,直接删除O(1)</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">removeHead</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    p<span class="token operator">-></span>next<span class="token operator">-></span>previous<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    L<span class="token operator">-></span><span class="token function">freeData</span><span class="token punctuation">(</span>p<span class="token operator">-></span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token operator">=</span>p<span class="token operator">-></span>previous<span class="token punctuation">;</span>    p<span class="token operator">-></span>previous<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    L<span class="token operator">-></span><span class="token function">freeData</span><span class="token punctuation">(</span>p<span class="token operator">-></span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="随机删除或者插入"><a href="#随机删除或者插入" class="headerlink" title="随机删除或者插入"></a>随机删除或者插入</h4><blockquote><p>我设计的是从头到尾顺序查找插入or删除,O(n),不过还可以优化判断一下从头还是从尾开始,这样可以减少循环次数.</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>index<span class="token operator">></span>L<span class="token operator">-></span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是头尾直接跳用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>index<span class="token operator">==</span>L<span class="token operator">-></span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>            L<span class="token operator">-></span><span class="token function">addHead</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            L<span class="token operator">-></span><span class="token function">addTail</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    LinkedListNode <span class="token operator">*</span>new<span class="token operator">=</span><span class="token punctuation">(</span>LinkedListNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">int</span> pos<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span>L<span class="token operator">-></span>head<span class="token operator">&amp;&amp;</span>pos<span class="token operator">&lt;</span>index<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token operator">++</span>pos<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    new<span class="token operator">-></span>dataType<span class="token operator">=</span>dataType<span class="token punctuation">;</span>    new<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    new<span class="token operator">-></span>previous<span class="token operator">=</span>p<span class="token punctuation">;</span>    p<span class="token operator">-></span>next<span class="token operator">-></span>previous<span class="token operator">=</span>new<span class="token punctuation">;</span>    p<span class="token operator">-></span>next<span class="token operator">=</span>new<span class="token punctuation">;</span>    <span class="token operator">++</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>index<span class="token operator">></span>L<span class="token operator">-></span>length<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是头尾直接跳用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>index<span class="token operator">==</span>L<span class="token operator">-></span>length<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>            L<span class="token operator">-></span><span class="token function">removeHead</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            L<span class="token operator">-></span><span class="token function">removeTail</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">int</span> pos<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span>L<span class="token operator">-></span>head<span class="token operator">&amp;&amp;</span>pos<span class="token operator">&lt;</span>index<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token operator">++</span>pos<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p<span class="token operator">-></span>next<span class="token operator">-></span>previous<span class="token operator">=</span>p<span class="token operator">-></span>previous<span class="token punctuation">;</span>    p<span class="token operator">-></span>previous<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    L<span class="token operator">-></span><span class="token function">freeData</span><span class="token punctuation">(</span>p<span class="token operator">-></span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="遍历函数和printData"><a href="#遍历函数和printData" class="headerlink" title="遍历函数和printData()"></a>遍历函数和printData()</h4><blockquote><p>前面说,类型数据不同,我们只把他设置接口进行了</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">do</span><span class="token punctuation">{</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">-></span><span class="token function">printData</span><span class="token punctuation">(</span>p<span class="token operator">-></span>dataType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">printDataType</span><span class="token punctuation">(</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n你应该重新写自己的printData,他的格式为:\n"</span>           <span class="token string">"Status printDataType(DataType *dataType);\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h4><blockquote><p>我们这里用快排,快排很适合双向链表,我们把<code>sort()</code>写成一个模板,比较因子让使用者自己写</p></blockquote><h4 id="clean-函数"><a href="#clean-函数" class="headerlink" title="clean()函数"></a>clean()函数</h4><blockquote><p>直接循环头删</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">clean</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">-></span><span class="token function">removeHead</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="freeData-函数"><a href="#freeData-函数" class="headerlink" title="freeData()函数"></a>freeData()函数</h4><blockquote><p>按需要,我们把他定义成接口就好了</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">freeData</span><span class="token punctuation">(</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="initLinked-List"><a href="#initLinked-List" class="headerlink" title="initLinked List()"></a>initLinked List()</h4><blockquote><p>这个函数非常重要,c语言所有结构体成员都需要赋值才能进行各种各样的操作,<code>LinkedList()</code>函数就不需要加关键字<code>static</code>了,初始函数是提供给其他文件访问的.</p></blockquote><pre class="line-numbers language-c"><code class="language-c">LinkedList <span class="token function">initLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    LinkedList L<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>head<span class="token operator">=</span><span class="token punctuation">(</span>LinkedListNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>head<span class="token operator">-></span>dataType<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>head<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token punctuation">.</span>head<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>head<span class="token operator">-></span>previous<span class="token operator">=</span>L<span class="token punctuation">.</span>head<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>get<span class="token operator">=</span>get<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>getHead<span class="token operator">=</span>getHead<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>getTail<span class="token operator">=</span>getTail<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>addHead<span class="token operator">=</span>addHead<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>addTail<span class="token operator">=</span>addTail<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>removeHead<span class="token operator">=</span>removeHead<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>removeTail<span class="token operator">=</span>removeTail<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>insert<span class="token operator">=</span>insert<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>delete<span class="token operator">=</span>delete<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>traversal<span class="token operator">=</span>traversal<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>sort<span class="token operator">=</span>sort<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>clean<span class="token operator">=</span>clean<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>printData<span class="token operator">=</span>printDataType<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>freeData<span class="token operator">=</span>freeData<span class="token punctuation">;</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>如果有错误,请你联系骂我,(写的什么辣鸡代码),把错误不足的地方骂出来,我也是第一次想到这样写C语言代码,可能这个操作网上只有我一个吧!</p></li><li><p>这样写对从面对过程的c转到其他面对对象高级语言希望有点帮助</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java日志</title>
      <link href="/2019/10/03/java-ri-zhi/"/>
      <url>/2019/10/03/java-ri-zhi/</url>
      
        <content type="html"><![CDATA[<p>其实我Java挺菜的真的菜</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构浅谈</title>
      <link href="/2019/10/03/shu-ju-jie-gou-qian-tan/"/>
      <url>/2019/10/03/shu-ju-jie-gou-qian-tan/</url>
      
        <content type="html"><![CDATA[<p>数据结构是啥呢?</p><p>答案: 在12月里面找</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作</title>
      <link href="/2019/10/03/c-yu-yan-wen-jian-cao-zuo/"/>
      <url>/2019/10/03/c-yu-yan-wen-jian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据的输入和输出几乎伴随着每个 C 语言程序，所谓输入就是从“源端”获取数据，所谓输出可以理解为向“终端”写入数据。这里的源端可以是键盘、鼠标、硬盘、光盘、扫描仪等输入设备，终端可以是显示器、硬盘、打印机等输出设备。在 C 语言中，把这些输入和输出设备也看作“文件”。</p></blockquote><h2 id="1-文件和其类别"><a href="#1-文件和其类别" class="headerlink" title="1.文件和其类别"></a>1.文件和其类别</h2><p>  计算机上的各种资源都是由操作系统管理和控制的，操作系统中的文件系统，是专门负责将外部存储设备中的信息组织方式进行统一管理规划，以便为程序访问数据提供统一的方式。</p><p>文件是操作系统管理数据的基本单位，文件一般是指存储在外部存储介质上的有名字的一系列相关数据的有序集合。它是程序对数据进行读写操作的基本对象。在 C 语言中，把输入和输出设备都看作文件。</p><p><strong>文件一般包括三要素：</strong><code>文件路径</code>、<code>文件名</code>、<code>后缀</code>。</p><h3 id="1-1文件路径"><a href="#1-1文件路径" class="headerlink" title="1.1文件路径"></a>1.1文件路径</h3><blockquote><p>由于在 C 语言中<code>'\'</code> 一般是转义字符的起始标志，故在路径中需要用<code>两个 '\'</code> 表示路径中目录层次的间隔，也可以使用<code>'/'</code>作为路径中的分隔符。</p></blockquote><p>例如，”E:\ch10.doc”或者”E:/ch10.doc”，表示文件 ch10.doc 保存在 E 盘根目录下。”f1.txt” 表示当前目录下的文件 f1.txt。</p><p><strong>文件路径：</strong>可以显式指出其绝对路径，如上面的<code>”E:\\”</code>或者<code>”E:/”</code>等；如果没有显式指出其路径，默认为当前路径。<br>C 语言不仅支持对当前目录和根目录文件的操作，也支持对多级目录文件的操作，例如：</p><pre><code>D:\\C_WorkSpace\\Chapter_10\\file_1.txt</code></pre><p><strong>或者</strong></p><pre><code>D:/C_WorkSpace/Chapter_10/file_1.txt</code></pre><p>中的 file_1.txt 均是 C 语言可操作的多级目录文件。</p><h3 id="1-2文件名"><a href="#1-2文件名" class="headerlink" title="1.2文件名"></a>1.2文件名</h3><blockquote><p><strong>文件名：</strong>标识文件名字的合法标识符，如 ch10、file_1 等都是合法的文件名。</p></blockquote><p><strong>后缀：</strong>一般用于标明文件的类型，使用方式为：<code>文件名.后缀</code>，即文件名与后缀之间用<code>'.'</code> 隔开。常见的后缀类型有：<code>doc</code>、<code>txt</code>、<code>dat</code>、<code>c</code>、<code>cpp</code>、<code>obj</code>、<code>exe</code>、<code>bmp</code>、<code>jpg</code>、<code>png</code>、<code>js</code>、<code>html</code>、<code>pdf</code> 等。</p><h3 id="1-3文件结构"><a href="#1-3文件结构" class="headerlink" title="1.3文件结构"></a>1.3文件结构</h3><blockquote><p>文件按其逻辑结构可分为：<code>记录文件</code>和<code>流式文件</code>。而记录文件又可分为：<code>顺序文件</code>、<code>索引文件</code>、<code>索引顺序文件</code>及<code>散列文件</code>等。</p></blockquote><p>流式文件是以<code>字节</code>为单位，对流式文件的访问一般采用<code>穷举搜索</code>的方式，效率不高，故一般需频繁访问的较大数据不适宜采用流式文件逻辑结构。但由于流式文件<code>管理简单</code>，用户可以较方便地对文件进行相关操作。</p><h2 id="2-流的概念和分类"><a href="#2-流的概念和分类" class="headerlink" title="2.流的概念和分类"></a>2.流的概念和分类</h2><blockquote><p>I/O 设备的多样性及复杂性，给程序设计者访问这些设备带来了很大的难度和不便。为此，ANSIC 的 I/O 系统即标准 I/O 系统，把任意输入的源端或任意输出的终端，都抽象转换成了概念上的“标准 I/O 设备”或称“标准逻辑设备”。程序绕过具体设备，直接与该“标准逻辑设备”进行交互，这样就为程序设计者提供了一个不依赖于任何具体 I/O 设备的统一操作接口，<code>通常把抽象出来的“标准逻辑设备”或“标准文件”称作“流”</code>.</p></blockquote><h3 id="2-1流介绍"><a href="#2-1流介绍" class="headerlink" title="2.1流介绍"></a>2.1流介绍</h3><blockquote><p>把任意 I/O 设备，转换成逻辑意义上的“标准 I/O 设备”或“标准文件”的过程，并不需要程序设计者感知和处理，是由标准 I/O 系统自动转换完成的。故从这个意义上，可以认为任意输入的源端和任意输出的终端均对应一个“流”。</p></blockquote><p><strong>流按方向分为：</strong><code>输入流</code>和<code>输出流</code>。从文件获取数据的流称为输入流，向文件输出数据称为输出流。</p><p>例如，从键盘输入数据然后把该数据输出到屏幕上的过程，相当于从一个文件输入流（与键盘相关）中输入（读取）数据，然后通过另外一个文件输出流（与显示器相关）把获取的数据输出（写入）到文件（显示器）上。</p><p><strong>流按数据形式分为：</strong><code>文本流</code>和<code>二进制流</code>。文本流是ASCII 码<code>字符序列</code>，而二进制流是<code>字节序列</code>。</p><h3 id="2-2文本文件与二进制文件"><a href="#2-2文本文件与二进制文件" class="headerlink" title="2.2文本文件与二进制文件"></a>2.2文本文件与二进制文件</h3><ul><li><strong>文本文件：</strong>把要存储的数据当成一系列字符组成，把每个字符的 <code>ASCII 码值</code>存入文件中。每个 ASCII 码值占一个字节，每个字节表示一个字符。故文本文件也称作字符文件或 ASCII 文件，是<code>字符序列</code>文件。</li><li><strong>二进制文件：</strong>把数据对应的二进制形式存储到文件中，是<code>字节序列</code>文件。</li></ul><p>例如数据 123，如果按文本文件形式存储，把数据看成三个字符：’1’、’2’、’3’ 的集合，文件中依次存储各个字符的 <code>ASCII 码值</code>，格式如表 所示。</p><table><thead><tr><th>字符</th><th>‘1’</th><th>‘2’</th><th>‘3’</th></tr></thead><tbody><tr><td>ASCII(十进制)</td><td>49</td><td>50</td><td>51</td></tr><tr><td>ASCII(二进制)</td><td>0011 001</td><td>0011 0010</td><td>0011 0011</td></tr></tbody></table><p>如果按照二进制文件形式存储，则把数据 123 看成整型数，如果该系统中整型数占 4 个字节，则数据 123 二进制存储形式的 4 个字节如下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0111</span> <span class="token number">1011</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-文件的打开与关闭"><a href="#3-文件的打开与关闭" class="headerlink" title="3.文件的打开与关闭"></a>3.文件的打开与关闭</h2><blockquote><p>C 程序中对任何文件进行操作，都必须先“打开”文件，即打开流；操作完成后，需“关闭”文件，即关闭流。可调用标准库 <code>stdio.h</code> 中的<code>fopen()</code> 和 <code>fclose()</code> 函数实现。</p></blockquote><p><strong>打开函数 fopen() 的原型如下</strong></p><pre class="line-numbers language-c"><code class="language-c">FILE <span class="token operator">*</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>函数参数：</strong></p><ul><li><code>filename</code>: 文件名，包括路径，如果不显式含有路径，则表示当前路径。例如，“D:\f1.txt”表示 D 盘根目录下的文件 f1.txt 文件。“f2.doc”表示当前目录下的文件 f2.doc。</li><li><code>mode</code>: 文件打开模式，指出对该文件可进行的操作。常见的打开模式如 “r” 表示只读，“w” 表示只写，“rw” 表示读写，“a” 表示追加写入。更多的打开模式请看下文。</li></ul><p><strong>返回值：</strong>打开成功，返回该文件对应的 FILE 类型的指针；打开失败，返回 NULL。故<code>需定义 FILE 类型的指针变量，保存该函数的返回值</code>。可根据该函数的返回值判断文件打开是否成功。</p><h3 id="打开模式"><a href="#打开模式" class="headerlink" title="打开模式"></a>打开模式</h3><blockquote><p>在C语言的文件操作语法中，打开文件文件有以下12种模式，如下图： </p></blockquote><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-2zr8{background-color:#009901;border-color:#000000;text-align:center;vertical-align:middle}.tg .tg-hgci{color:#6200c9;border-color:#000000;text-align:center;vertical-align:middle}.tg .tg-p57i{background-color:#ffce93;color:#fe0000;border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-mcug{background-color:#68cbd0;border-color:#000000;text-align:center;vertical-align:middle}.tg .tg-erxi{color:#6200c9;border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-du2d{color:#009901;border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-i218{color:#009901;text-align:center;vertical-align:top}</style><table class="tg">  <tbody><tr>    <th class="tg-mcug">打开模式</th>    <th class="tg-mcug">只可读</th>    <th class="tg-mcug" colspan="2">只可写</th>    <th class="tg-2zr8" colspan="3">读写皆可</th>  </tr>  <tr>    <td class="tg-p57i">文本模式</td>    <td class="tg-erxi">r</td>    <td class="tg-erxi">w </td>    <td class="tg-hgci">a</td>    <td class="tg-du2d">r+</td>    <td class="tg-du2d">w+</td>    <td class="tg-i218">a+</td>  </tr>  <tr>    <td class="tg-p57i">二进制模式</td>    <td class="tg-erxi">rb</td>    <td class="tg-erxi">wb</td>    <td class="tg-erxi">ab</td>    <td class="tg-du2d">rb+或r+b</td>    <td class="tg-du2d">wb或w+b</td>    <td class="tg-i218">ab+或a+b</td>  </tr></tbody></table><blockquote><p>其中，<code>二进制模式</code>与<code>文本模式</code>操作相似，只不过是以二进制流的形式读写而已，下面以<code>文本模式为例</code>分析：</p></blockquote><ol><li><p><strong>“r” 模式：</strong></p><ul><li>打开文件进行<code>“只读”</code>操作，即只能从文件读取内容。</li><li>若欲操作的<code>文件不存在，则打开失败</code>。</li><li>成功打开文件时，文件指针位于<code>文件开头</code>。</li><li>打开文件后，<code>不会清空</code>文件内原有内容。</li><li>可从文件中<code>任意位置</code>读取内容。</li></ul></li><li><p><strong>“w” 模式：</strong></p><ul><li>打开文件进行<code>“只写”</code>操作，即只能向文件写入内容。</li><li>若欲操作的<code>文件不存在，则新建文件</code>。</li><li>成功打开文件时，文件指针位于文件<code>开头</code>。</li><li>打开文件后，<code>会清空文件</code>内原有的内容。</li><li>可向文件中<code>任意位置</code>写入内容，且进行写入操作时，<code>会覆盖原有位置的内容</code>。</li></ul></li><li><p><strong>“a” 模式：</strong></p><ul><li>打开文件进行<code>“追加”</code>操作，即只能向文件写入内容。</li><li>若欲操作的<code>文件不存在，则新建文件</code>。</li><li>成功打开文件时，文件指针位于<code>文件结尾</code>。</li><li>打开文件后，<code>不会清空</code>文件内原有内容。</li><li>只能向文件<code>末尾追加</code>(写)内容。</li></ul></li><li><p><strong>“r+”模式：</strong></p><ul><li>打开文件进行<code>“读写”</code>操作，即既可读取，又可写入。</li><li>若欲操作的<code>文件不存在，则打开失败</code>。</li><li>成功打开文件时，文件指针位于<code>文件开头</code>。</li><li>打开文件后，<code>不会清空</code>文件内原有内容。</li><li>无论是读取内容还是写入内容，都可在文件中<code>任意位置</code>进行，且进行写入操作时，<code>会覆盖原有位置的内容</code>。</li></ul></li><li><p><strong>“w+”模式：</strong></p><ul><li>打开文件进行<code>“读写”</code>操作，即既可读取，又可写入。</li><li>若欲操作的<code>文件不存在，则新建文件</code>。</li><li>成功打开文件时，文件指针位于<code>文件开头</code>。</li><li>打开文件后，<code>会清空文件</code>内原有的内容。</li><li>无论是读取内容还是写入内容，都可在文件中任意位置进行，且进行写入操作时，会覆盖原有位置的内容。</li></ul></li><li><p><strong>“a+”模式：</strong></p><ul><li>打开文件进行<code>“读写”</code>操作，即既可读取，又可写入。</li><li>若欲操作的<code>文件不存在，则新建文件</code>。</li><li>成功打开文件时，文件指针位于<code>文件结尾</code>。</li><li>打开文件后，<code>不会清空</code>文件内原有内容。</li><li>读取内容时，可以在<code>任意位置</code>进行，但写入内容时，只会<code>追加在文件尾部</code>。</li></ul></li></ol><p><code>不同的打开模式对应不同的操作方式，使用时需仔细规划。</code></p><p><strong>关闭函数 fclose 的原型如下。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fclose</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>函数参数：</strong>fp:已打开的文件指针。</p><p><strong>返回值：</strong>正常关闭，返回否则返回 EOF(-1)。<br><strong>示例</strong></p><pre class="line-numbers language-c"><code class="language-c">FILE fpl<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span>”D<span class="token punctuation">:</span>\\fl<span class="token punctuation">.</span>txt”，”r”）<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//以只读模式打开文件 fl.txt</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>fpl<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//以返回值fpl判断是否打开成功，如果为NULL表示失败</span><span class="token punctuation">{</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Failed to open the file !\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//终止程序，stdlib .h头文件中</span><span class="token punctuation">}</span>FILE fp2<span class="token operator">=</span><span class="token function">fopen</span> <span class="token punctuation">(</span><span class="token string">"f2.txt"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//以追加写入的模式打开文件f2 .txt</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>fp2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Failed to open the file !\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fclose</span> <span class="token punctuation">(</span>fpl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关闭fpl指针对应文件（fl.txt)的流</span><span class="token function">fclose</span> <span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关闭fp2指针对应文件（f2.txt)的流</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于换行符"><a href="#关于换行符" class="headerlink" title="关于换行符"></a>关于换行符</h2><blockquote><p>我们知道在UNIX下是没有回车符（\r）的，只有换行符（\n），而C语言诞生于UNIX（Linux即面向开源的UNIX，Mac OS也是UNIX发展而来的，而Windows是从MS-DOS发展而来，与前两者不同），所以C语言的源代码文件中也是以 \n 表示换行。</p><blockquote><ul><li><code>回车'\r'</code>:表示光标回到该行的行首处。</li><li><code>换行'\n'</code>:表示光标从当前行该列位置移动到下一行对应的该列位置。</li></ul></blockquote></blockquote><p>所以总结一下：</p><p>Windows下换行采用 \r\n 表示，全称回车换行符。</p><p>UNIX（Linux）下换行采用 \n 表示，即换行符。</p><p>Mac OS下换行采用 \r 表示，即回车符。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scanf()和printf()函数详解</title>
      <link href="/2019/09/20/scanf-he-printf-han-shu-xiang-jie/"/>
      <url>/2019/09/20/scanf-he-printf-han-shu-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="1-printf-简介"><a href="#1-printf-简介" class="headerlink" title="1.printf()简介"></a>1.printf()简介</h2><blockquote><p>printf() 是 C 语言标准库函数，用于将格式化后的字符串输出到标准输出。标准输出，即标准输出文件，对应终端的屏幕。printf() 申明于头文件 stdio.h。</p></blockquote><p><strong>函数原型</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">printf</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>返回值</strong></p><blockquote><p>正确返回输出的字符总数，错误返回负值。与此同时，输入输出流错误标志将被置值，可由指示器函数 ferror(FILE *stream) 来检查输入输出流的错误标志，如果 ferror() 返回一个非零值，表示出错。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>输出结果</code><br>Hello World!<br>13<br><strong>调用格式</strong></p><blockquote><p>字符串常量原样输出，在显示中起提示作用。输出表列中给出了各个输出项，要求格式控制字符串和各输出项在数量和类型上应该一一对应。其中格式控制字符串是以 % 开头的字符串，在 % 后面跟有各种格式控制符，以说明输出数据的类型、宽度、精度等。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"格式化字符串"</span><span class="token punctuation">,</span> 输出表列<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span>prec<span class="token punctuation">]</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span>type<span class="token operator">%</span><span class="token punctuation">[</span>标志<span class="token punctuation">]</span><span class="token punctuation">[</span>最小宽度<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span>精度<span class="token punctuation">]</span><span class="token punctuation">[</span>类型长度<span class="token punctuation">]</span>类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-1-类型-type"><a href="#1-1-类型-type" class="headerlink" title="1.1 类型(type)"></a>1.1 类型(type)</h3><blockquote><p>首先说明类型，因为类型是格式控制字符串的重中之重，是必不可少的组成部分，其它的选项都是可选的。type 用于规定输出数据的类型，含义如下：</p></blockquote><table><thead><tr><th align="center">字符</th><th align="center">对应数据类型</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td align="center">d/i</td><td align="center">int</td><td>输出十进制有符号32bits整数，i是老式写法</td><td><code>printf("%i",123);</code>输出123</td></tr><tr><td align="center">o</td><td align="center">unsigned int</td><td>无符号8进制(octal)整数(不输出前缀0)</td><td><code>printf("0%o",123);</code>输出0173</td></tr><tr><td align="center">u</td><td align="center">unsigned int</td><td>无符号10进制整数</td><td><code>printf("%u",123);</code>输出123</td></tr><tr><td align="center">x/X</td><td align="center">unsigned int</td><td>无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF（不输出前缀0x)</td><td><code>printf("0x%x 0x%X",123,123);</code>输出0x7b 0x7B</td></tr><tr><td align="center">f/lf</td><td align="center">float(double)</td><td>单精度浮点数用f,双精度浮点数用lf(printf可混用，但scanf不能混用)</td><td><code>printf("%.9f %.9lf",0.000000123,0.000000123);</code>输出0.000000123 0.000000123。注意指定精度，否则printf默认精确到小数点后六位</td></tr><tr><td align="center">F</td><td align="center">float(double)</td><td>与f格式相同，只不过 infinity 和 nan 输出为大写形式。</td><td>例如<code>printf("%f %F %f %F\n",INFINITY,INFINITY,NAN,NAN);</code>输出结果为inf INF nan NAN</td></tr><tr><td align="center">e/E</td><td align="center">float(double)</td><td>科学计数法，使用指数(Exponent)表示浮点数，此处”e”的大小写代表在输出时“e”的大小写</td><td><code>printf("%e %E",0.000000123,0.000000123);</code>输出1.230000e-07 1.230000E-07</td></tr><tr><td align="center">g</td><td align="center">float(double)</td><td>根据数值的长度，选择以最短的方式输出，%f或%e</td><td><code>printf("%g %g",0.000000123,0.123);</code>输出1.23e-07 0.123</td></tr><tr><td align="center">G</td><td align="center">float(double)</td><td>根据数值的长度，选择以最短的方式输出，%f或%E</td><td><code>printf("%G %G",0.000000123,0.123);</code>输出1.23E-07 0.123</td></tr><tr><td align="center">c</td><td align="center">char</td><td>字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</td><td><code>printf("%c\n",64);</code>输出A</td></tr><tr><td align="center">s</td><td align="center">char*</td><td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以空字符’\0‘结尾）</td><td><code>printf("%s","测试test");</code>输出：测试test</td></tr><tr><td align="center">S</td><td align="center">wchar_t*</td><td>宽字符串。输出字符串中的字符直至字符串中的空字符（宽字符串以两个空字符’\0‘结尾）</td><td><code>setlocale(LC_ALL,"zh_CN.UTF-8");wchar_t wtest[]=L</code>“测试Test”;<code>printf("%S\n",wtest);</code>==输出：测试test==</td></tr><tr><td align="center">p</td><td align="center">void*</td><td>以16进制形式输出指针</td><td><code>printf("0x%p","lvlv");</code>输出：0x000000013FF73350</td></tr><tr><td align="center">n</td><td align="center">int*</td><td>什么也不输出。%n对应的参数是一个指向signed int的指针，在此之前输出的字符数将存储到指针所指的位置    int num=0;</td><td><code>printf("lvlv%n",&amp;num);printf("num:%d",num);</code>==输出:lvlvnum:4==</td></tr><tr><td align="center">%</td><td align="center">字符%</td><td>输出字符‘%’（百分号）本身</td><td><code>printf("%%");</code>    输出:%</td></tr><tr><td align="center">m</td><td align="center">无</td><td>打印errno值对应的出错内容</td><td><code>printf("%m\n");</code></td></tr><tr><td align="center">a/A</td><td align="center">float(double)</td><td>十六进制p计数法输出浮点数，a为小写，A为大写</td><td><code>printf("%a %A",15.15,15.15);</code>输出：0x1.e4ccccccccccdp+3 0X1.E4CCCCCCCCCCDP+3</td></tr></tbody></table><p><strong>注意</strong></p><ol><li>使用 printf() 输出宽字符时，需要使用 setlocale 指定本地化信息并同时指明当前代码的编码方式。除了使用 %S，还可以使用 %ls。</li><li>%a 和 %A 是 C99 引入的格式化类型，采用十六进制 p 计数法输出浮点数。p 计数法类似 E 科学计数法，但有所不同。数以 0x 开头，然后是 16 进制浮点数部分，接着是 p 后面是以 2 为底的阶码。以上面输出的 15.15 为例，推算输出结果。15.15 转换成二进制为<code>1111.00 1001 1001 1001 1001 ...</code>，因为二进制表示数值的离散特点，计算机对于小数有时是不能精确表示的，比如 0.5 可以精确表示为1<sub>2</sub>，而 0.15 却不能精确表示。将15.15 对应的二进制右移三位，为<code>1.1110 0100 1100 1100 1100 ...</code>转换对应的十六进制就是<code>0x1.e4ccccccccccd</code>，注意舍入时向高位进了1位。由于右移三位，所以二进制阶码是 3。最后的结果就是 <code>0x1.e4ccccccccccdp+3</code>。</li><li>格式控制字符串除了指明输出的数据类型，还可以包含一些其它的可选的格式说明，依序有 flags, width, .precision and length。下面一一讲解.</li></ol><h3 id="1-2-标志（flags）"><a href="#1-2-标志（flags）" class="headerlink" title="1.2 标志（flags）"></a>1.2 标志（flags）</h3><blockquote><p>flags 规定输出样式，取值和含义如下:</p></blockquote><table><thead><tr><th align="center">字符</th><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">减号</td><td align="center">结果左对齐，右边填空格。默认是右对齐，左边填空格。</td></tr><tr><td align="center">+</td><td align="center">加号</td><td align="center">输出符号(正号或负号)</td></tr><tr><td align="center">space</td><td align="center">空格</td><td align="center">输出值为正时加上空格，为负时加上负号</td></tr><tr><td align="center">#</td><td align="center">井号</td><td align="center">type是o、x、X时，增加前缀0、0x、0X。==type是a、A、e、E、f、g、G时，<code>一定使用小数点</code>。默认的，如果使用.0控制不输出小数部分，则不输出小数点。type是g、G时，尾部的0保留。==</td></tr><tr><td align="center">0</td><td align="center">数字零</td><td align="center">将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用“-”）</td></tr></tbody></table><blockquote><p>示例:</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%5d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//默认右对齐,左边补空格</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-5d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//左对齐,右边补空格</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%+d %+d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出正负号</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"% d % d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//正号用空格替代，负号输出</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x %#x\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出0x</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.0f %#.0f\n"</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//当小数点后不输出值时依然输出小数点</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%g %#g\n"</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//保留小数点后后的0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%05d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//前面补0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果</strong></p><pre class="line-numbers language-c"><code class="language-c"> <span class="token number">1000</span><span class="token number">1000</span> <span class="token operator">+</span><span class="token number">1000</span> <span class="token operator">-</span><span class="token number">1000</span> <span class="token number">1000</span> <span class="token operator">-</span><span class="token number">1000</span><span class="token number">3e8</span> <span class="token number">0x3e8</span><span class="token number">1000</span> <span class="token number">1000</span><span class="token punctuation">.</span><span class="token number">1000</span> <span class="token number">1000.0</span><span class="token number">01000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-输出最小宽度（width）"><a href="#1-3-输出最小宽度（width）" class="headerlink" title="1.3 输出最小宽度（width）"></a>1.3 输出最小宽度（width）</h3><blockquote><p>用十进制整数来表示输出的最少位数。若实际位数多于指定的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。width的可能取值如下：</p></blockquote><table><thead><tr><th align="center">width</th><th align="center">描述</th><th>示例</th></tr></thead><tbody><tr><td align="center">数值</td><td align="center">十进制整数</td><td><code>printf("%06d",1000);</code>输出:001000</td></tr><tr><td align="center">*</td><td align="center">星号</td><td>不显示指明输出最小宽度，而是以星号代替，在printf的输出参数列表中给出</td></tr></tbody></table><h3 id="1-4-精度（-precision）"><a href="#1-4-精度（-precision）" class="headerlink" title="1.4 精度（.precision）"></a>1.4 精度（.precision）</h3><blockquote><p>精度格式符以<code>“.”</code>开头，后跟十进制整数。可取值如下：</p></blockquote><table><thead><tr><th align="center">.precision</th><th>描述</th></tr></thead><tbody><tr><td align="center">.数值</td><td>十进制整数。<br>(1)对于整型（d,i,o,u,x,X）,precision表示输出的最小的数字个数，不足补前导零，超过不截断。<br> (2)对于浮点型（a, A, e, E, f ），precision表示小数点后数值位数，默认为六位，不足补后置0，超过则截断。<br>(3)对于类型说明符g或G，表示可输出的最大有效数字。<br>(4)对于字符串（s），precision表示最大可输出字符数，不足正常输出，超过则截断。<br><code>precision不显示指定，则默认为0</code></td></tr><tr><td align="center">.*</td><td>以星号代替数值，类似于width中的*，在输出参数列表中指定精度。</td></tr></tbody></table><p><strong>示例:</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//不足指定宽度补前导0，效果等同于%08d</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8f\n"</span><span class="token punctuation">,</span><span class="token number">1000.123456789</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//超过精度，截断</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8f\n"</span><span class="token punctuation">,</span><span class="token number">1000.123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不足精度，补后置0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8g\n"</span><span class="token punctuation">,</span><span class="token number">1000.123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//最大有效数字为8位</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8s\n"</span><span class="token punctuation">,</span>“abcdefghij”<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//超过指定长度截断</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token number">00001000</span><span class="token number">1000.12345679</span><span class="token number">1000.12345600</span><span class="token number">1000.1235</span>abcdefgh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意:</strong><code>在对浮点数和整数截断时，存在四舍五入。</code></p><h3 id="1-5-类型长度（length）"><a href="#1-5-类型长度（length）" class="headerlink" title="1.5 类型长度（length）"></a>1.5 类型长度（length）</h3><blockquote><p>类型长度指明待输出数据的长度。因为相同类型可以有不同的长度，比如整型有 16bits 的 short int，32bits的int，也有 64bits 的 long int，浮点型有32bits的单精度 float 和 64bits 的双精度 double。为了指明同一类型的不同长度，于是乎，类型长度（length）应运而生，成为格式控制字符串的一部分。</p></blockquote><table><thead><tr><th align="center">符号</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">hh</td><td align="center">与d、i 一起使用，表示一个signed char 类型的值；与o、u、x、X—起使用，表示一个unsigned char 类型的值；与 n 一起使用，表示相应的变元是指向 signed char 型变量的指针（c99 )</td></tr><tr><td align="center">h</td><td align="center">与d、i、o、u、x、X 或 n 一起使用，表示一个short int 或 unsigned short int 类型的值</td></tr><tr><td align="center">l</td><td align="center">与d、i、o、u、x、X 或 n 一起使用，表示一个 long int 或者 unsigned long int 类型的值</td></tr><tr><td align="center">ll</td><td align="center">与 d、i、o、u、x、X 或 n —起使用，表示相应的变元是 long long int 或 unsigned long long int 类型的值(c99 )</td></tr><tr><td align="center">j</td><td align="center">与 d、i、o、u、x、X 或 n —起使用，表示匹配的变元是 intmax_t 或 uintmax_t 类型，这些类型在“stdint. h”中声明（c99 )</td></tr><tr><td align="center">z</td><td align="center">与 d、i、o、u、x、X 或 n —起使用，表示匹配的变元是指向 size_t 类型对象的指针，该类型在“stddef. h”中声明(c99 )</td></tr><tr><td align="center">t</td><td align="center">与d、i、o、u、x、X 或 n —起使用，表示匹配的变元是指向 ptrdiff_t 类型对象的指针，该类型在“stddef. h”中声明(c99 )</td></tr><tr><td align="center">L</td><td align="center">和a、A、e、E、f、F、g、G—起使用，表示一个long double类型的值</td></tr></tbody></table><p><strong>注意:</strong></p><ul><li>long int到底是32bits还是64bits跟生成的程序是32bits还是64bits一一对应，如果使用g++编译程序的话，可通过<code>-m32</code>或<code>-m64</code>选项分别生成32bits和64bits的程序</li></ul><ul><li>除此之外，每一个输出参数的输出格式都必须有对应的格式说明符与之一一对应，并且类型必须匹配。若二者不能够一一对应匹配，则不能够正确输出，而且编译时可能不会报错。</li><li>同时，若格式说明符个数少于输出项个数，则多余的输出项将不予输出；若格式说明符个数多于输出项个数，则可能会输出一些毫无意义的数字乱码。</li></ul><h2 id="2-scanf-简介"><a href="#2-scanf-简介" class="headerlink" title="2.scanf()简介"></a>2.scanf()简介</h2><blockquote><p>相对于 printf 函数，scanf 函数就简单得多。scanf 函数的功能与 printf 函数正好相反，执行格式化输入功能。即 scanf 函数从格式串的最左端开始，每遇到一个字符便将其与下一个输入字符进行“匹配”，如果二者匹配（相同）则继续，否则结束对后面输入的处理。而每遇到一个格式说明符，便按该格式说明符所描述的格式对其后的输入值进行转换，然后将其存于与其对应的输入地址中.</p></blockquote><p><strong>函数原型</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">printf</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>返回值</strong></p><blockquote><p>当格式化字符串format到达末尾或者读取的输入不再匹配格式字符串所指定的类型时，输入就停止，并返回被转换的输入值的数目,若在任何输入都没被转换之前文件就到达尾部则返回EOF。</p></blockquote><p><strong>示例</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    num<span class="token operator">=</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入:<br>1 2 3<br>徐南木<br><strong>结果</strong></p><pre><code>1 2 33徐南木1</code></pre><p><strong>调用格式</strong></p><blockquote><p>由于scanf是采用可变参数的机制，所以函数无法验证它们的指针参数是否为正确的类型，所以函数假定它们是正确的，（因此格式字符必须和后面的指针指向的类型保持一致）如果指针参数的类型和输入数据的类型不匹配则结果值就是垃圾。而且邻近的变量也有可能被改写</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"格式化字符串"</span><span class="token punctuation">,</span> 输入表列<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span> type_char<span class="token operator">%</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">[</span>宽度<span class="token punctuation">]</span><span class="token punctuation">[</span>长度<span class="token punctuation">]</span>类型符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示:</strong>数据类型和格式输入可参考<code>printf()</code>函数.</p><h3 id="2-1-捕获规则"><a href="#2-1-捕获规则" class="headerlink" title="2.1 捕获规则"></a>2.1 捕获规则</h3><blockquote><p>在出现一个转换说明符时，scanf函数会忽略前面的所有空白字符（除了%c），然后再捕获相应的数据类型，一直到最大长度或者出现空白字符</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>允许的输入格式为：1,2\n；1,  2\n；1,\n2\n；</code><br><code>不允许的输入格式：1 ,2\n；   \n1,2\n； 1,2\n；</code>  </p><h3 id="2-2-scanf-中的空格和-n"><a href="#2-2-scanf-中的空格和-n" class="headerlink" title="2.2 scanf()中的空格和\n"></a>2.2 scanf()中的空格和\n</h3><blockquote><p>scanf中的空格的作用不仅仅是捕获一个空格，它表示捕获所有空白字符（空格，换行，制表符等）直到出现一个非空白字符（\n一样），例如</p></blockquote><p>我们想接受一个ip:端口的输入<br>需要接受的输入格式为：<code>ip:端口</code>，<code>ip: 端口</code>，<code>ip : 端口</code>，<code>ip\n:\n端口</code><br>如果代码为</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d.%d.%d.%d:%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则只能捕获的格式：<code>ip:端口</code>，<code>ip: 端口</code>，<code>ip:\n端口</code>;<br>如果我们将代码改为</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d.%d.%d.%d :%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>:</code>前面多了一个空格,则可以捕获上述所有情况.</p><h3 id="2-3-正则表达"><a href="#2-3-正则表达" class="headerlink" title="2.3 正则表达"></a>2.3 正则表达</h3><blockquote><p>scanf()函数正则表达严格意义上不是,只能算伪正则表达且只能用于<code>string</code></p><blockquote><ul><li>[]内是匹配的字符,^表示求反集，当遇到非集合内的字符时立即终止输入</li><li>%表示选择，%后面的是条件</li><li>%* 与%刚好相反，表示过滤满足条件的字符，也就是跳过满足条件的字符，其后一定要有新的%语句，否则无法读入</li></ul></blockquote></blockquote><ol><li><p>输入指定范围的小写字母，遇到非法字符立即终止</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-z]"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入：xunanmu123<br>输出:<code>xunamu</code></p></li><li><p>获取指定范围的小写字母和数字</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-z0-9]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>​<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入：xunanmu123<br>输出：<code>xunanmu123</code></p></li><li><p>获取带空格的自定范围的字符串</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-z A-Z0-9]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入：123xu nan mu Blog<br>输出:<code>123xu nan mu Blog</code></p></li><li><p>输入<code>不带</code>空格的自定范围的字符串</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-zA-Z0-9]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入：123xu nan mu Blog<br>输出:<code>123xu</code></p></li></ol><p><strong>注意:scanf()字符串默认空格结束</strong></p><ol start="5"><li>获取不包括指定字符的字符<pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[^a-z]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>输入：23 徐南木 BLOG Aabc<br>输出：<code>23 徐南木 BLOG A</code></li></ol><p><strong>注意：这种方式可以读入空格</strong></p><ol start="6"><li><p>获取一整行字符串，包括空格</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[^\n]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入：23 徐南木 BLOG Aabc<br>输出：<code>23 徐南木 BLOG Aabc</code></p></li><li><p>%* 跳过指定范围的字符再读取指定范围的字符</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%*[a-z0-9]%[^\n]"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入: abc 徐南木  xnm<br>输出:<code>徐南木 xnm</code></p></li><li><p>找了俩道经典的<code>%*``%</code>匹配<br>例1：从<a href="sip:tom@172.18.1.133" target="_blank" rel="noopener">sip:tom@172.18.1.133</a>中提取tom</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> url <span class="token operator">=</span> <span class="token string">"&lt;sip:tom@172.18.1.133>"</span><span class="token punctuation">;</span> <span class="token keyword">char</span> uri<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">sscanf</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token string">"%*[^:]:%[^@]"</span><span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例2：从iios/12DDWDFF@122中提取12DDWDFF</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s <span class="token operator">=</span> <span class="token string">"iios/12DDWDFF@122"</span><span class="token punctuation">;</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">sscanf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"%*[^/]/%[^@]"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="3-转义字符"><a href="#3-转义字符" class="headerlink" title="3.转义字符"></a>3.转义字符</h2><blockquote><p>转义字符在字符串中会被自动转换为相应操作命令。printf()使用的常见转义字符如下：</p></blockquote><table><thead><tr><th align="center">转义字符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">\a</td><td align="center">警报(响铃)符</td></tr><tr><td align="center">\b</td><td align="center">回退符</td></tr><tr><td align="center">\f</td><td align="center">换页符</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\r</td><td align="center">回车符</td></tr><tr><td align="center">\t</td><td align="center">横向制表符</td></tr><tr><td align="center">\v</td><td align="center">纵向制表符</td></tr><tr><td align="center">\</td><td align="center">反斜杠</td></tr><tr><td align="center">“</td><td align="center">双引号</td></tr></tbody></table><h2 id="4-关于缓冲区"><a href="#4-关于缓冲区" class="headerlink" title="4.关于缓冲区"></a>4.关于缓冲区</h2><h3 id="4-1-关于printf缓冲"><a href="#4-1-关于printf缓冲" class="headerlink" title="4.1 关于printf缓冲"></a>4.1 关于printf缓冲</h3><blockquote><p>在 printf 的实现中，在调用 write 之前先写入 IO 缓冲区，这是一个用户空间的缓冲。系统调用是软中断，频繁调用，需要频繁陷入内核态，这样的效率不是很高，而 printf 实际是向用户空间的 IO 缓冲写，在满足条件的情况下才会调用 write 系统调用，减少IO次数，提高效率。<br>printf 在 <code>glibc</code>    中默认为行缓冲，遇到以下几种情况会刷新缓冲区，输出内容：</p></blockquote><ul><li>（1）缓冲区填满；</li><li>（2）写入的字符中有换行符\n或回车符\r；</li><li>（3）调用<code>fflush</code>手动刷新缓冲区；</li><li>（4）调用scanf要从输入缓冲区中读取数据时，也会将输出缓冲区内的数据刷新。<br>可使用<code>setbuf(stdout,NULL)</code>关闭行缓冲，或者<code>setbuf(stdout,uBuff)</code>设置新的缓冲区，uBuff为自己指定的缓冲区。也可以使用<code>setvbuf(stdout,NULL,_IOFBF,0)</code>;来改变标准输出为全缓冲。全缓冲与行缓冲的区别在于遇到换行符不刷新缓冲区。</li></ul><p><code>printf 在 VC++ 中默认关闭缓冲区，输出时会及时的输到屏幕。如果显示开启缓冲区，只能设置全缓冲.</code></p><h3 id="4-2-关于scanf缓冲"><a href="#4-2-关于scanf缓冲" class="headerlink" title="4.2 关于scanf缓冲"></a>4.2 关于scanf缓冲</h3><blockquote><p>在使用 scanf 函数的时候，需要特别注意的就是缓冲区问题。对 scanf 函数来说，估计最容易出错、最令人捉摸不透的问题应该是缓冲区问题了。</p><blockquote></blockquote><ul><li>标准输入缓冲区 stdin 使用行缓冲的方式存储输入。用户的输入数据首先被暂存在临时缓冲区中，当用户键入回车键或临时缓冲区满后，stdin 才进行 I/O 操作，将数据由临时缓冲区拷贝至 stdin 中。C语言提供的输入输出函数如 scanf 、getchar 等则从上述缓冲区 stdin 中读取数据输入。</li></ul></blockquote><p>　　scanf 和 getchar 等函数会在<code>stdin</code> 中读取数据，若上述缓冲区中已存在数据，则直接读取其中的数据，若上述缓冲区为空，则上述函数会挂起，等待数据缓冲的完成( 用户输入回车键或数据缓冲区满后， stdin 会进行数据缓冲，之后上述函数才能继续执行)。 用户一次输入的数据可能会超过 scanf 、getchar 等函数调用所需要的数据，那么所需数据被读取后，剩余的数据仍会存放在缓冲区中，之后的函数调用会直接读取 stdin 中已有的数据。只有当缓冲区为空后，scanf 等函数才会等待用户输入,实际应该是等待<code>stdin</code>的缓冲。<br><strong>解决办法</strong></p><ol><li>最简单就是在scanf()函数扫描前留空格.<pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">" %c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>可以使用 <code>fflush()</code> 函数清理缓冲区。C标准规定 fflush()函数可用来刷新输出（stdout）缓冲区(一般是将缓冲区数据写回存储设备)。但对于标准输入（stdin）则没有明确定义。部分编译器定义了 fflush( stdin )的实现，如微软的VC。也就是不同的编译器对于 fflush( stdin )的支持可能不同。<code>GCC编译器没有定义它的实现，所以不能使用 fflush( stdin )来刷新输入缓冲区。</code></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> 正则表达 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
