<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>scanf()和printf()函数详解</title>
      <link href="/2019/09/20/scanf-he-printf-han-shu-xiang-jie/"/>
      <url>/2019/09/20/scanf-he-printf-han-shu-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="1-printf-简介"><a href="#1-printf-简介" class="headerlink" title="1.printf()简介"></a>1.printf()简介</h2><blockquote><p>printf() 是 C 语言标准库函数，用于将格式化后的字符串输出到标准输出。标准输出，即标准输出文件，对应终端的屏幕。printf() 申明于头文件 stdio.h。</p></blockquote><p><strong>函数原型</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">printf</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>返回值</strong></p><blockquote><p>正确返回输出的字符总数，错误返回负值。与此同时，输入输出流错误标志将被置值，可由指示器函数 ferror(FILE *stream) 来检查输入输出流的错误标志，如果 ferror() 返回一个非零值，表示出错。</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>输出结果</code><br>Hello World!<br>13<br><strong>调用格式</strong></p><blockquote><p>字符串常量原样输出，在显示中起提示作用。输出表列中给出了各个输出项，要求格式控制字符串和各输出项在数量和类型上应该一一对应。其中格式控制字符串是以 % 开头的字符串，在 % 后面跟有各种格式控制符，以说明输出数据的类型、宽度、精度等。</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"格式化字符串"</span><span class="token punctuation">,</span> 输出表列<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span>prec<span class="token punctuation">]</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span>type<span class="token operator">%</span><span class="token punctuation">[</span>标志<span class="token punctuation">]</span><span class="token punctuation">[</span>最小宽度<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span>精度<span class="token punctuation">]</span><span class="token punctuation">[</span>类型长度<span class="token punctuation">]</span>类型</code></pre><h3 id="1-1-类型-type"><a href="#1-1-类型-type" class="headerlink" title="1.1 类型(type)"></a>1.1 类型(type)</h3><blockquote><p>首先说明类型，因为类型是格式控制字符串的重中之重，是必不可少的组成部分，其它的选项都是可选的。type 用于规定输出数据的类型，含义如下：</p></blockquote><table><thead><tr><th align="center">字符</th><th align="center">对应数据类型</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td align="center">d/i</td><td align="center">int</td><td>输出十进制有符号32bits整数，i是老式写法</td><td><code>printf("%i",123);</code>输出123</td></tr><tr><td align="center">o</td><td align="center">unsigned int</td><td>无符号8进制(octal)整数(不输出前缀0)</td><td><code>printf("0%o",123);</code>输出0173</td></tr><tr><td align="center">u</td><td align="center">unsigned int</td><td>无符号10进制整数</td><td><code>printf("%u",123);</code>输出123</td></tr><tr><td align="center">x/X</td><td align="center">unsigned int</td><td>无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF（不输出前缀0x)</td><td><code>printf("0x%x 0x%X",123,123);</code>输出0x7b 0x7B</td></tr><tr><td align="center">f/lf</td><td align="center">float(double)</td><td>单精度浮点数用f,双精度浮点数用lf(printf可混用，但scanf不能混用)</td><td><code>printf("%.9f %.9lf",0.000000123,0.000000123);</code>输出0.000000123 0.000000123。注意指定精度，否则printf默认精确到小数点后六位</td></tr><tr><td align="center">F</td><td align="center">float(double)</td><td>与f格式相同，只不过 infinity 和 nan 输出为大写形式。</td><td>例如<code>printf("%f %F %f %F\n",INFINITY,INFINITY,NAN,NAN);</code>输出结果为inf INF nan NAN</td></tr><tr><td align="center">e/E</td><td align="center">float(double)</td><td>科学计数法，使用指数(Exponent)表示浮点数，此处”e”的大小写代表在输出时“e”的大小写</td><td><code>printf("%e %E",0.000000123,0.000000123);</code>输出1.230000e-07 1.230000E-07</td></tr><tr><td align="center">g</td><td align="center">float(double)</td><td>根据数值的长度，选择以最短的方式输出，%f或%e</td><td><code>printf("%g %g",0.000000123,0.123);</code>输出1.23e-07 0.123</td></tr><tr><td align="center">G</td><td align="center">float(double)</td><td>根据数值的长度，选择以最短的方式输出，%f或%E</td><td><code>printf("%G %G",0.000000123,0.123);</code>输出1.23E-07 0.123</td></tr><tr><td align="center">c</td><td align="center">char</td><td>字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</td><td><code>printf("%c\n",64);</code>输出A</td></tr><tr><td align="center">s</td><td align="center">char*</td><td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以空字符’\0‘结尾）</td><td><code>printf("%s","测试test");</code>输出：测试test</td></tr><tr><td align="center">S</td><td align="center">wchar_t*</td><td>宽字符串。输出字符串中的字符直至字符串中的空字符（宽字符串以两个空字符’\0‘结尾）</td><td><code>setlocale(LC_ALL,"zh_CN.UTF-8");wchar_t wtest[]=L</code>“测试Test”;<code>printf("%S\n",wtest);</code>==输出：测试test==</td></tr><tr><td align="center">p</td><td align="center">void*</td><td>以16进制形式输出指针</td><td><code>printf("0x%p","lvlv");</code>输出：0x000000013FF73350</td></tr><tr><td align="center">n</td><td align="center">int*</td><td>什么也不输出。%n对应的参数是一个指向signed int的指针，在此之前输出的字符数将存储到指针所指的位置    int num=0;</td><td><code>printf("lvlv%n",&amp;num);printf("num:%d",num);</code>==输出:lvlvnum:4==</td></tr><tr><td align="center">%</td><td align="center">字符%</td><td>输出字符‘%’（百分号）本身</td><td><code>printf("%%");</code>    输出:%</td></tr><tr><td align="center">m</td><td align="center">无</td><td>打印errno值对应的出错内容</td><td><code>printf("%m\n");</code></td></tr><tr><td align="center">a/A</td><td align="center">float(double)</td><td>十六进制p计数法输出浮点数，a为小写，A为大写</td><td><code>printf("%a %A",15.15,15.15);</code>输出：0x1.e4ccccccccccdp+3 0X1.E4CCCCCCCCCCDP+3</td></tr></tbody></table><p><strong>注意</strong></p><ol><li>使用 printf() 输出宽字符时，需要使用 setlocale 指定本地化信息并同时指明当前代码的编码方式。除了使用 %S，还可以使用 %ls。</li><li>%a 和 %A 是 C99 引入的格式化类型，采用十六进制 p 计数法输出浮点数。p 计数法类似 E 科学计数法，但有所不同。数以 0x 开头，然后是 16 进制浮点数部分，接着是 p 后面是以 2 为底的阶码。以上面输出的 15.15 为例，推算输出结果。15.15 转换成二进制为<code>1111.00 1001 1001 1001 1001 ...</code>，因为二进制表示数值的离散特点，计算机对于小数有时是不能精确表示的，比如 0.5 可以精确表示为1<sub>2</sub>，而 0.15 却不能精确表示。将15.15 对应的二进制右移三位，为<code>1.1110 0100 1100 1100 1100 ...</code>转换对应的十六进制就是<code>0x1.e4ccccccccccd</code>，注意舍入时向高位进了1位。由于右移三位，所以二进制阶码是 3。最后的结果就是 <code>0x1.e4ccccccccccdp+3</code>。</li><li>格式控制字符串除了指明输出的数据类型，还可以包含一些其它的可选的格式说明，依序有 flags, width, .precision and length。下面一一讲解.</li></ol><h3 id="1-2-标志（flags）"><a href="#1-2-标志（flags）" class="headerlink" title="1.2 标志（flags）"></a>1.2 标志（flags）</h3><blockquote><p>flags 规定输出样式，取值和含义如下:</p></blockquote><table><thead><tr><th align="center">字符</th><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">减号</td><td align="center">结果左对齐，右边填空格。默认是右对齐，左边填空格。</td></tr><tr><td align="center">+</td><td align="center">加号</td><td align="center">输出符号(正号或负号)</td></tr><tr><td align="center">space</td><td align="center">空格</td><td align="center">输出值为正时加上空格，为负时加上负号</td></tr><tr><td align="center">#</td><td align="center">井号</td><td align="center">type是o、x、X时，增加前缀0、0x、0X。==type是a、A、e、E、f、g、G时，<code>一定使用小数点</code>。默认的，如果使用.0控制不输出小数部分，则不输出小数点。type是g、G时，尾部的0保留。==</td></tr><tr><td align="center">0</td><td align="center">数字零</td><td align="center">将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用“-”）</td></tr></tbody></table><blockquote><p>示例:</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%5d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//默认右对齐,左边补空格</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-5d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//左对齐,右边补空格</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%+d %+d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出正负号</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"% d % d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//正号用空格替代，负号输出</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x %#x\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出0x</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.0f %#.0f\n"</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//当小数点后不输出值时依然输出小数点</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%g %#g\n"</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//保留小数点后后的0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%05d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//前面补0</span></code></pre><p><strong>结果</strong></p><pre class=" language-c"><code class="language-c"> <span class="token number">1000</span><span class="token number">1000</span> <span class="token operator">+</span><span class="token number">1000</span> <span class="token operator">-</span><span class="token number">1000</span> <span class="token number">1000</span> <span class="token operator">-</span><span class="token number">1000</span><span class="token number">3e8</span> <span class="token number">0x3e8</span><span class="token number">1000</span> <span class="token number">1000</span><span class="token punctuation">.</span><span class="token number">1000</span> <span class="token number">1000.0</span><span class="token number">01000</span></code></pre><h3 id="1-3-输出最小宽度（width）"><a href="#1-3-输出最小宽度（width）" class="headerlink" title="1.3 输出最小宽度（width）"></a>1.3 输出最小宽度（width）</h3><blockquote><p>用十进制整数来表示输出的最少位数。若实际位数多于指定的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。width的可能取值如下：</p></blockquote><table><thead><tr><th align="center">width</th><th align="center">描述</th><th>示例</th></tr></thead><tbody><tr><td align="center">数值</td><td align="center">十进制整数</td><td><code>printf("%06d",1000);</code>输出:001000</td></tr><tr><td align="center">*</td><td align="center">星号</td><td>不显示指明输出最小宽度，而是以星号代替，在printf的输出参数列表中给出</td></tr></tbody></table><h3 id="1-4-精度（-precision）"><a href="#1-4-精度（-precision）" class="headerlink" title="1.4 精度（.precision）"></a>1.4 精度（.precision）</h3><blockquote><p>精度格式符以<code>“.”</code>开头，后跟十进制整数。可取值如下：</p></blockquote><table><thead><tr><th align="center">.precision</th><th>描述</th></tr></thead><tbody><tr><td align="center">.数值</td><td>十进制整数。<br>(1)对于整型（d,i,o,u,x,X）,precision表示输出的最小的数字个数，不足补前导零，超过不截断。<br> (2)对于浮点型（a, A, e, E, f ），precision表示小数点后数值位数，默认为六位，不足补后置0，超过则截断。<br>(3)对于类型说明符g或G，表示可输出的最大有效数字。<br>(4)对于字符串（s），precision表示最大可输出字符数，不足正常输出，超过则截断。<br><code>precision不显示指定，则默认为0</code></td></tr><tr><td align="center">.*</td><td>以星号代替数值，类似于width中的*，在输出参数列表中指定精度。</td></tr></tbody></table><p><strong>示例:</strong></p><pre class=" language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//不足指定宽度补前导0，效果等同于%08d</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8f\n"</span><span class="token punctuation">,</span><span class="token number">1000.123456789</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//超过精度，截断</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8f\n"</span><span class="token punctuation">,</span><span class="token number">1000.123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不足精度，补后置0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8g\n"</span><span class="token punctuation">,</span><span class="token number">1000.123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//最大有效数字为8位</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8s\n"</span><span class="token punctuation">,</span>“abcdefghij”<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//超过指定长度截断</span></code></pre><p><strong>结果</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">00001000</span><span class="token number">1000.12345679</span><span class="token number">1000.12345600</span><span class="token number">1000.1235</span>abcdefgh</code></pre><p><strong>注意:</strong><code>在对浮点数和整数截断时，存在四舍五入。</code></p><h3 id="1-5-类型长度（length）"><a href="#1-5-类型长度（length）" class="headerlink" title="1.5 类型长度（length）"></a>1.5 类型长度（length）</h3><blockquote><p>类型长度指明待输出数据的长度。因为相同类型可以有不同的长度，比如整型有 16bits 的 short int，32bits的int，也有 64bits 的 long int，浮点型有32bits的单精度 float 和 64bits 的双精度 double。为了指明同一类型的不同长度，于是乎，类型长度（length）应运而生，成为格式控制字符串的一部分。</p></blockquote><table><thead><tr><th align="center">符号</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">hh</td><td align="center">与d、i 一起使用，表示一个signed char 类型的值；与o、u、x、X—起使用，表示一个unsigned char 类型的值；与 n 一起使用，表示相应的变元是指向 signed char 型变量的指针（c99 )</td></tr><tr><td align="center">h</td><td align="center">与d、i、o、u、x、X 或 n 一起使用，表示一个short int 或 unsigned short int 类型的值</td></tr><tr><td align="center">l</td><td align="center">与d、i、o、u、x、X 或 n 一起使用，表示一个 long int 或者 unsigned long int 类型的值</td></tr><tr><td align="center">ll</td><td align="center">与 d、i、o、u、x、X 或 n —起使用，表示相应的变元是 long long int 或 unsigned long long int 类型的值(c99 )</td></tr><tr><td align="center">j</td><td align="center">与 d、i、o、u、x、X 或 n —起使用，表示匹配的变元是 intmax_t 或 uintmax_t 类型，这些类型在“stdint. h”中声明（c99 )</td></tr><tr><td align="center">z</td><td align="center">与 d、i、o、u、x、X 或 n —起使用，表示匹配的变元是指向 size_t 类型对象的指针，该类型在“stddef. h”中声明(c99 )</td></tr><tr><td align="center">t</td><td align="center">与d、i、o、u、x、X 或 n —起使用，表示匹配的变元是指向 ptrdiff_t 类型对象的指针，该类型在“stddef. h”中声明(c99 )</td></tr><tr><td align="center">L</td><td align="center">和a、A、e、E、f、F、g、G—起使用，表示一个long double类型的值</td></tr></tbody></table><p><strong>注意:</strong></p><ul><li>long int到底是32bits还是64bits跟生成的程序是32bits还是64bits一一对应，如果使用g++编译程序的话，可通过<code>-m32</code>或<code>-m64</code>选项分别生成32bits和64bits的程序</li></ul><ul><li>除此之外，每一个输出参数的输出格式都必须有对应的格式说明符与之一一对应，并且类型必须匹配。若二者不能够一一对应匹配，则不能够正确输出，而且编译时可能不会报错。</li><li>同时，若格式说明符个数少于输出项个数，则多余的输出项将不予输出；若格式说明符个数多于输出项个数，则可能会输出一些毫无意义的数字乱码。</li></ul><h2 id="2-scanf-简介"><a href="#2-scanf-简介" class="headerlink" title="2.scanf()简介"></a>2.scanf()简介</h2><blockquote><p>相对于 printf 函数，scanf 函数就简单得多。scanf 函数的功能与 printf 函数正好相反，执行格式化输入功能。即 scanf 函数从格式串的最左端开始，每遇到一个字符便将其与下一个输入字符进行“匹配”，如果二者匹配（相同）则继续，否则结束对后面输入的处理。而每遇到一个格式说明符，便按该格式说明符所描述的格式对其后的输入值进行转换，然后将其存于与其对应的输入地址中.</p></blockquote><p><strong>函数原型</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">printf</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>返回值</strong></p><blockquote><p>当格式化字符串format到达末尾或者读取的输入不再匹配格式字符串所指定的类型时，输入就停止，并返回被转换的输入值的数目,若在任何输入都没被转换之前文件就到达尾部则返回EOF。</p></blockquote><p><strong>示例</strong></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    num<span class="token operator">=</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输入:<br>1 2 3<br>徐南木<br><strong>结果</strong></p><pre><code>1 2 33徐南木1</code></pre><p><strong>调用格式</strong></p><blockquote><p>由于scanf是采用可变参数的机制，所以函数无法验证它们的指针参数是否为正确的类型，所以函数假定它们是正确的，（因此格式字符必须和后面的指针指向的类型保持一致）如果指针参数的类型和输入数据的类型不匹配则结果值就是垃圾。而且邻近的变量也有可能被改写</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"格式化字符串"</span><span class="token punctuation">,</span> 输入表列<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span> type_char<span class="token operator">%</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">[</span>宽度<span class="token punctuation">]</span><span class="token punctuation">[</span>长度<span class="token punctuation">]</span>类型符</code></pre><p><strong>提示:</strong>数据类型和格式输入可参考<code>printf()</code>函数.</p><h3 id="2-1-捕获规则"><a href="#2-1-捕获规则" class="headerlink" title="2.1 捕获规则"></a>2.1 捕获规则</h3><blockquote><p>在出现一个转换说明符时，scanf函数会忽略前面的所有空白字符（除了%c），然后再捕获相应的数据类型，一直到最大长度或者出现空白字符</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p><code>允许的输入格式为：1,2\n；1,  2\n；1,\n2\n；</code><br><code>不允许的输入格式：1 ,2\n；   \n1,2\n； 1,2\n；</code>  </p><h3 id="2-2-scanf-中的空格和-n"><a href="#2-2-scanf-中的空格和-n" class="headerlink" title="2.2 scanf()中的空格和\n"></a>2.2 scanf()中的空格和\n</h3><blockquote><p>scanf中的空格的作用不仅仅是捕获一个空格，它表示捕获所有空白字符（空格，换行，制表符等）直到出现一个非空白字符（\n一样），例如</p></blockquote><p>我们想接受一个ip:端口的输入<br>需要接受的输入格式为：<code>ip:端口</code>，<code>ip: 端口</code>，<code>ip : 端口</code>，<code>ip\n:\n端口</code><br>如果代码为</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d.%d.%d.%d:%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>`</code></pre><p>则只能捕获的格式：<code>ip:端口</code>，<code>ip: 端口</code>，<code>ip:\n端口</code>;<br>如果我们将代码改为</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d.%d.%d.%d :%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>:</code>前面多了一个空格,则可以捕获上述所有情况.</p><h3 id="2-3-正则表达"><a href="#2-3-正则表达" class="headerlink" title="2.3 正则表达"></a>2.3 正则表达</h3><blockquote><p>scanf()函数正则表达严格意义上不是,只能算伪正则表达且只能用于<code>string</code></p><blockquote><ul><li>[]内是匹配的字符,^表示求反集，当遇到非集合内的字符时立即终止输入</li><li>%表示选择，%后面的是条件</li><li>%* 与%刚好相反，表示过滤满足条件的字符，也就是跳过满足条件的字符，其后一定要有新的%语句，否则无法读入</li></ul></blockquote></blockquote><ol><li><p>输入指定范围的小写字母，遇到非法字符立即终止</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-z]"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入：xunanmu123<br>输出:<code>xunamu</code></p></li><li><p>获取指定范围的小写字母和数字</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-z0-9]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>​<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入：xunanmu123<br>输出：<code>xunanmu123</code></p></li><li><p>获取带空格的自定范围的字符串</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-z A-Z0-9]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入：123xu nan mu Blog<br>输出:<code>123xu nan mu Blog</code></p></li><li><p>输入<code>不带</code>空格的自定范围的字符串</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-zA-Z0-9]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入：123xu nan mu Blog<br>输出:<code>123xu</code></p></li></ol><p><strong>注意:scanf()字符串默认空格结束</strong></p><ol start="5"><li>获取不包括指定字符的字符<pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[^a-z]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>输入：23 徐南木 BLOG Aabc<br>输出：<code>23 徐南木 BLOG A</code></li></ol><p><strong>注意：这种方式可以读入空格</strong></p><ol start="6"><li><p>获取一整行字符串，包括空格</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[^\n]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入：23 徐南木 BLOG Aabc<br>输出：<code>23 徐南木 BLOG Aabc</code></p></li><li><p>%* 跳过指定范围的字符再读取指定范围的字符</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%*[a-z0-9]%[^\n]"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入: abc 徐南木  xnm<br>输出:<code>徐南木 xnm</code></p></li><li><p>找了俩道经典的<code>%*``%</code>匹配<br>例1：从<a href="sip:tom@172.18.1.133" target="_blank" rel="noopener">sip:tom@172.18.1.133</a>中提取tom</p><pre class=" language-c"><code class="language-c"> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> url <span class="token operator">=</span> <span class="token string">"&lt;sip:tom@172.18.1.133>"</span><span class="token punctuation">;</span> <span class="token keyword">char</span> uri<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">sscanf</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token string">"%*[^:]:%[^@]"</span><span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>例2：从iios/12DDWDFF@122中提取12DDWDFF</p><pre class=" language-c"><code class="language-c"> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s <span class="token operator">=</span> <span class="token string">"iios/12DDWDFF@122"</span><span class="token punctuation">;</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">sscanf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"%*[^/]/%[^@]"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h2 id="3-转义字符"><a href="#3-转义字符" class="headerlink" title="3.转义字符"></a>3.转义字符</h2><blockquote><p>转义字符在字符串中会被自动转换为相应操作命令。printf()使用的常见转义字符如下：</p></blockquote><table><thead><tr><th align="center">转义字符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">\a</td><td align="center">警报(响铃)符</td></tr><tr><td align="center">\b</td><td align="center">回退符</td></tr><tr><td align="center">\f</td><td align="center">换页符</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\r</td><td align="center">回车符</td></tr><tr><td align="center">\t</td><td align="center">横向制表符</td></tr><tr><td align="center">\v</td><td align="center">纵向制表符</td></tr><tr><td align="center">\</td><td align="center">反斜杠</td></tr><tr><td align="center">“</td><td align="center">双引号</td></tr></tbody></table><h2 id="4-关于缓冲区"><a href="#4-关于缓冲区" class="headerlink" title="4.关于缓冲区"></a>4.关于缓冲区</h2><h3 id="4-1-关于printf缓冲"><a href="#4-1-关于printf缓冲" class="headerlink" title="4.1 关于printf缓冲"></a>4.1 关于printf缓冲</h3><blockquote><p>在 printf 的实现中，在调用 write 之前先写入 IO 缓冲区，这是一个用户空间的缓冲。系统调用是软中断，频繁调用，需要频繁陷入内核态，这样的效率不是很高，而 printf 实际是向用户空间的 IO 缓冲写，在满足条件的情况下才会调用 write 系统调用，减少IO次数，提高效率。<br>printf 在 <code>glibc</code>    中默认为行缓冲，遇到以下几种情况会刷新缓冲区，输出内容：</p></blockquote><ul><li>（1）缓冲区填满；</li><li>（2）写入的字符中有换行符\n或回车符\r；</li><li>（3）调用<code>fflush</code>手动刷新缓冲区；</li><li>（4）调用scanf要从输入缓冲区中读取数据时，也会将输出缓冲区内的数据刷新。<br>可使用<code>setbuf(stdout,NULL)</code>关闭行缓冲，或者<code>setbuf(stdout,uBuff)</code>设置新的缓冲区，uBuff为自己指定的缓冲区。也可以使用<code>setvbuf(stdout,NULL,_IOFBF,0)</code>;来改变标准输出为全缓冲。全缓冲与行缓冲的区别在于遇到换行符不刷新缓冲区。</li></ul><p><code>printf 在 VC++ 中默认关闭缓冲区，输出时会及时的输到屏幕。如果显示开启缓冲区，只能设置全缓冲.</code></p><h3 id="4-2-关于scanf缓冲"><a href="#4-2-关于scanf缓冲" class="headerlink" title="4.2 关于scanf缓冲"></a>4.2 关于scanf缓冲</h3><blockquote><p>在使用 scanf 函数的时候，需要特别注意的就是缓冲区问题。对 scanf 函数来说，估计最容易出错、最令人捉摸不透的问题应该是缓冲区问题了。</p><blockquote></blockquote><ul><li>标准输入缓冲区 stdin 使用行缓冲的方式存储输入。用户的输入数据首先被暂存在临时缓冲区中，当用户键入回车键或临时缓冲区满后，stdin 才进行 I/O 操作，将数据由临时缓冲区拷贝至 stdin 中。C语言提供的输入输出函数如 scanf 、getchar 等则从上述缓冲区 stdin 中读取数据输入。</li></ul></blockquote><p>　　scanf 和 getchar 等函数会在<code>stdin</code> 中读取数据，若上述缓冲区中已存在数据，则直接读取其中的数据，若上述缓冲区为空，则上述函数会挂起，等待数据缓冲的完成( 用户输入回车键或数据缓冲区满后， stdin 会进行数据缓冲，之后上述函数才能继续执行)。 用户一次输入的数据可能会超过 scanf 、getchar 等函数调用所需要的数据，那么所需数据被读取后，剩余的数据仍会存放在缓冲区中，之后的函数调用会直接读取 stdin 中已有的数据。只有当缓冲区为空后，scanf 等函数才会等待用户输入,实际应该是等待<code>stdin</code>的缓冲。<br><strong>解决办法</strong></p><ol><li>最简单就是在scanf()函数扫描前留空格.<pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">" %c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>可以使用 <code>fflush()</code> 函数清理缓冲区。C标准规定 fflush()函数可用来刷新输出（stdout）缓冲区(一般是将缓冲区数据写回存储设备)。但对于标准输入（stdin）则没有明确定义。部分编译器定义了 fflush( stdin )的实现，如微软的VC。也就是不同的编译器对于 fflush( stdin )的支持可能不同。<code>GCC编译器没有定义它的实现，所以不能使用 fflush( stdin )来刷新输入缓冲区。</code></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> 正则表达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/17/hello-world/"/>
      <url>/2019/09/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
