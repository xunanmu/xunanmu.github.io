<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c语言链表封装</title>
      <link href="/2019/11/01/lian-biao-feng-zhuang/"/>
      <url>/2019/11/01/lian-biao-feng-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="链表基本介绍"><a href="#链表基本介绍" class="headerlink" title="链表基本介绍"></a>链表基本介绍</h2><blockquote><p>我们都学过链表,单链表,循环链表,双向链表. 有没有想过把这些链表操作全部结合到一起呢?</p></blockquote><p>把他们的函数调用像调用成员那样,直接用<code>.</code>就可以操作. </p><p>废话不多说,由于C语言不像C++可以直接在结构体<code>struct</code>定义函数成员,但是C语言精髓<code>指针</code>操作可以做到. 下面我们利用C语言的函数指针达到封装效果.</p><h3 id="定义链表"><a href="#定义链表" class="headerlink" title="定义链表"></a>定义链表</h3><ol><li><p>首先我们选创建一个<code>LinkedList.h</code>头文件</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> DATASTRUCT_LINKEDLIST_H</span><span class="token macro property">#<span class="token directive keyword">define</span> DATASTRUCT_LINKEDLIST_H </span><span class="token comment" spellcheck="true">//定义宏,防止编译器重复编译</span><span class="token comment" spellcheck="true">//在宏中间编写代码</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span>   </span><span class="token comment" spellcheck="true">//申请节点,需要用的头文件</span><span class="token macro property">#<span class="token directive keyword">define</span> true  (char)1 </span><span class="token comment" spellcheck="true">//由于c没有bool型,我们自定义bool</span><span class="token macro property">#<span class="token directive keyword">define</span> false (char)0</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> Status<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> DataType<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽象数据类型</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">//</span></code></pre></li><li><p>定义链表节点结构体,就是双向链表节点的结构体</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> LinkedListNode<span class="token punctuation">{</span>   <span class="token keyword">struct</span> LinkedListNode <span class="token operator">*</span>previous<span class="token punctuation">;</span>   <span class="token keyword">struct</span> LinkedListNode <span class="token operator">*</span>next<span class="token punctuation">;</span>   DataType <span class="token operator">*</span>dataType<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//抽象数据</span>  <span class="token punctuation">}</span>LinkedListNode<span class="token punctuation">;</span></code></pre></li><li><p>定义链表结构体</p><blockquote><p>想想需要哪些操作?</p></blockquote><ul><li><strong>链表长度:</strong> 我们把length定义int;</li><li><strong>获取节点:</strong> 我们把函数分成三个,一个头,一个尾,最后一个应该能随便访问任何一个位置</li><li><strong>增加节点:</strong> 同上面一样的操作,只不过我把随便增加节点函数命名插入<code>insert</code></li><li><strong>删除节点:</strong> 同上, 头尾移除命名为<code>remove</code>,能随便删除命为<code>delete</code></li><li><strong>遍历:</strong> 我们创建了链表,肯定得瞅一瞅,不过这个得结合<code>printData()</code>这个函数</li><li><strong>排序:</strong> 我们偶尔也要排排成绩嘛,:raised_hand_with_fingers_splayed: 我成绩一般都是前五(倒序排)</li><li><strong>清空:</strong> 链表数据没有用了我们就把他清空掉</li><li><strong>printData:</strong> 定义打印数据的接口,学生,教师,图书,物品每一种数据结构都不一样,这个需要重新定义</li><li><strong>freeData:</strong> 当你需要删除动态数据时候你需要重新定义,默认空函数;</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> LinkedList<span class="token punctuation">{</span>    LinkedListNode <span class="token operator">*</span>head<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>    DataType<span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>get<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    DataType<span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>getHead<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    DataType<span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>getTail<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>addHead<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>addTail<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>removeHead<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>removeTail<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>insert<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>delete<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>traversal<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>sort<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>clean<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>printData<span class="token punctuation">)</span><span class="token punctuation">(</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>freeData<span class="token punctuation">)</span><span class="token punctuation">(</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>LinkedList<span class="token punctuation">;</span></code></pre></li><li><p>结构体定义完了,我们需要初始化这些数据,接下来定义初始化函数(类似<code>new</code>这个操作,只不过我们是静态分配,我们也可以写成动态定义)</p><pre class=" language-c"><code class="language-c"> LinkedList <span class="token function">initLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><ol><li><p>我们创建一个<code>LinkedList.c</code> 文件</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LinkedList.h"</span></span><span class="token comment" spellcheck="true">//这个必须包含进去</span></code></pre></li><li><p>*<em>相信你们都熟悉链表操作函数,在这里我要谈一下,咱们得把函数设置成<code>static</code>这个主要屏蔽外部文件访问这个函数,主要还是避免日后写了个重复函数名  *</em></p><blockquote><p>对了,前面忘说了,我们把这个链表设置有头节点的,方便操作.</p></blockquote></li></ol><h4 id="获取节点函数"><a href="#获取节点函数" class="headerlink" title="获取节点函数"></a><strong><em>获取节点函数</em></strong></h4><pre class=" language-c"><code class="language-c">   <span class="token keyword">static</span> DataType <span class="token operator">*</span><span class="token function">get</span><span class="token punctuation">(</span>LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>index<span class="token operator">></span>L<span class="token operator">-></span>length<span class="token operator">||</span>index<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> pos<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>       LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>L<span class="token operator">-></span>head<span class="token operator">&amp;&amp;</span>pos<span class="token operator">&lt;</span>index<span class="token punctuation">)</span>       <span class="token punctuation">{</span>           p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>           <span class="token operator">++</span>pos<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> p<span class="token operator">-></span>dataType<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">static</span> DataType <span class="token operator">*</span><span class="token function">getHead</span><span class="token punctuation">(</span>LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token operator">-></span>dataType<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">static</span> DataType <span class="token operator">*</span><span class="token function">getTail</span><span class="token punctuation">(</span>LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token operator">-></span>dataType<span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre><h4 id="头尾加函数"><a href="#头尾加函数" class="headerlink" title="头尾加函数"></a><strong><em>头尾加函数</em></strong></h4><blockquote><p> 利用循环链表的特性,直接添加O(1)</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">addHead</span><span class="token punctuation">(</span>LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">{</span>    LinkedListNode <span class="token operator">*</span>new<span class="token operator">=</span><span class="token punctuation">(</span>LinkedListNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    new<span class="token operator">-></span>dataType<span class="token operator">=</span>dataType<span class="token punctuation">;</span>    new<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token punctuation">;</span>    new<span class="token operator">-></span>previous<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token operator">-></span>previous<span class="token operator">=</span>new<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token operator">=</span>new<span class="token punctuation">;</span>    <span class="token operator">++</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">addTail</span><span class="token punctuation">(</span>LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">{</span>    LinkedListNode <span class="token operator">*</span>new<span class="token operator">=</span><span class="token punctuation">(</span>LinkedListNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    new<span class="token operator">-></span>dataType<span class="token operator">=</span>dataType<span class="token punctuation">;</span>    new<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    new<span class="token operator">-></span>previous<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token operator">-></span>next<span class="token operator">=</span>new<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token operator">=</span>new<span class="token punctuation">;</span>    <span class="token operator">++</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="头尾删除函数"><a href="#头尾删除函数" class="headerlink" title="头尾删除函数"></a>头尾删除函数</h4><blockquote><p>利用循环链表的特性,直接删除O(1)</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">removeHead</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    p<span class="token operator">-></span>next<span class="token operator">-></span>previous<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    L<span class="token operator">-></span><span class="token function">freeData</span><span class="token punctuation">(</span>p<span class="token operator">-></span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token punctuation">;</span>    L<span class="token operator">-></span>head<span class="token operator">-></span>previous<span class="token operator">=</span>p<span class="token operator">-></span>previous<span class="token punctuation">;</span>    p<span class="token operator">-></span>previous<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    L<span class="token operator">-></span><span class="token function">freeData</span><span class="token punctuation">(</span>p<span class="token operator">-></span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="随机删除或者插入"><a href="#随机删除或者插入" class="headerlink" title="随机删除或者插入"></a>随机删除或者插入</h4><blockquote><p>我设计的是从头到尾顺序查找插入or删除,O(n),不过还可以优化判断一下从头还是从尾开始,这样可以减少循环次数.</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>index<span class="token operator">></span>L<span class="token operator">-></span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是头尾直接跳用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>index<span class="token operator">==</span>L<span class="token operator">-></span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>            L<span class="token operator">-></span><span class="token function">addHead</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            L<span class="token operator">-></span><span class="token function">addTail</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    LinkedListNode <span class="token operator">*</span>new<span class="token operator">=</span><span class="token punctuation">(</span>LinkedListNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">int</span> pos<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span>L<span class="token operator">-></span>head<span class="token operator">&amp;&amp;</span>pos<span class="token operator">&lt;</span>index<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token operator">++</span>pos<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    new<span class="token operator">-></span>dataType<span class="token operator">=</span>dataType<span class="token punctuation">;</span>    new<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    new<span class="token operator">-></span>previous<span class="token operator">=</span>p<span class="token punctuation">;</span>    p<span class="token operator">-></span>next<span class="token operator">-></span>previous<span class="token operator">=</span>new<span class="token punctuation">;</span>    p<span class="token operator">-></span>next<span class="token operator">=</span>new<span class="token punctuation">;</span>    <span class="token operator">++</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>index<span class="token operator">></span>L<span class="token operator">-></span>length<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是头尾直接跳用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>index<span class="token operator">==</span>L<span class="token operator">-></span>length<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>            L<span class="token operator">-></span><span class="token function">removeHead</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            L<span class="token operator">-></span><span class="token function">removeTail</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">int</span> pos<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span>L<span class="token operator">-></span>head<span class="token operator">&amp;&amp;</span>pos<span class="token operator">&lt;</span>index<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token operator">++</span>pos<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p<span class="token operator">-></span>next<span class="token operator">-></span>previous<span class="token operator">=</span>p<span class="token operator">-></span>previous<span class="token punctuation">;</span>    p<span class="token operator">-></span>previous<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    L<span class="token operator">-></span><span class="token function">freeData</span><span class="token punctuation">(</span>p<span class="token operator">-></span>dataType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="遍历函数和printData"><a href="#遍历函数和printData" class="headerlink" title="遍历函数和printData()"></a>遍历函数和printData()</h4><blockquote><p>前面说,类型数据不同,我们只把他设置接口进行了</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    LinkedListNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">do</span><span class="token punctuation">{</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">-></span><span class="token function">printData</span><span class="token punctuation">(</span>p<span class="token operator">-></span>dataType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> Status <span class="token function">printDataType</span><span class="token punctuation">(</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n你应该重新写自己的printData,他的格式为:\n"</span>           <span class="token string">"Status printDataType(DataType *dataType);\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h4><blockquote><p>我们这里用快排,快排很适合双向链表,我们把<code>sort()</code>写成一个模板,比较因子让使用者自己写</p></blockquote><h4 id="clean-函数"><a href="#clean-函数" class="headerlink" title="clean()函数"></a>clean()函数</h4><blockquote><p>直接循环头删</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">clean</span><span class="token punctuation">(</span><span class="token keyword">struct</span> LinkedList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">-></span><span class="token function">removeHead</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="freeData-函数"><a href="#freeData-函数" class="headerlink" title="freeData()函数"></a>freeData()函数</h4><blockquote><p>按需要,我们把他定义成接口就好了</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> Status <span class="token function">freeData</span><span class="token punctuation">(</span>DataType <span class="token operator">*</span>dataType<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h4 id="initLinked-List"><a href="#initLinked-List" class="headerlink" title="initLinked List()"></a>initLinked List()</h4><blockquote><p>这个函数非常重要,c语言所有结构体成员都需要赋值才能进行各种各样的操作,<code>LinkedList()</code>函数就不需要加关键字<code>static</code>了,初始函数是提供给其他文件访问的.</p></blockquote><pre class=" language-c"><code class="language-c">LinkedList <span class="token function">initLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    LinkedList L<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>head<span class="token operator">=</span><span class="token punctuation">(</span>LinkedListNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>head<span class="token operator">-></span>dataType<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>head<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token punctuation">.</span>head<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>head<span class="token operator">-></span>previous<span class="token operator">=</span>L<span class="token punctuation">.</span>head<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>get<span class="token operator">=</span>get<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>getHead<span class="token operator">=</span>getHead<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>getTail<span class="token operator">=</span>getTail<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>addHead<span class="token operator">=</span>addHead<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>addTail<span class="token operator">=</span>addTail<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>removeHead<span class="token operator">=</span>removeHead<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>removeTail<span class="token operator">=</span>removeTail<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>insert<span class="token operator">=</span>insert<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>delete<span class="token operator">=</span>delete<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>traversal<span class="token operator">=</span>traversal<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>sort<span class="token operator">=</span>sort<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>clean<span class="token operator">=</span>clean<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>printData<span class="token operator">=</span>printDataType<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>freeData<span class="token operator">=</span>freeData<span class="token punctuation">;</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>如果有错误,请你联系骂我,(写的什么辣鸡代码),把错误不足的地方骂出来,我也是第一次想到这样写C语言代码,可能这个操作网上只有我一个吧!</p></li><li><p>这样写对从面对过程的c转到其他面对对象高级语言希望有点帮助</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java日志</title>
      <link href="/2019/10/03/java-ri-zhi/"/>
      <url>/2019/10/03/java-ri-zhi/</url>
      
        <content type="html"><![CDATA[<p>其实我Java挺菜的真的菜</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构浅谈</title>
      <link href="/2019/10/03/shu-ju-jie-gou-qian-tan/"/>
      <url>/2019/10/03/shu-ju-jie-gou-qian-tan/</url>
      
        <content type="html"><![CDATA[<p>数据结构是啥呢?</p><p>答案: 在12月里面找</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作</title>
      <link href="/2019/10/03/c-yu-yan-wen-jian-cao-zuo/"/>
      <url>/2019/10/03/c-yu-yan-wen-jian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据的输入和输出几乎伴随着每个 C 语言程序，所谓输入就是从“源端”获取数据，所谓输出可以理解为向“终端”写入数据。这里的源端可以是键盘、鼠标、硬盘、光盘、扫描仪等输入设备，终端可以是显示器、硬盘、打印机等输出设备。在 C 语言中，把这些输入和输出设备也看作“文件”。</p></blockquote><h2 id="1-文件和其类别"><a href="#1-文件和其类别" class="headerlink" title="1.文件和其类别"></a>1.文件和其类别</h2><p>  计算机上的各种资源都是由操作系统管理和控制的，操作系统中的文件系统，是专门负责将外部存储设备中的信息组织方式进行统一管理规划，以便为程序访问数据提供统一的方式。</p><p>文件是操作系统管理数据的基本单位，文件一般是指存储在外部存储介质上的有名字的一系列相关数据的有序集合。它是程序对数据进行读写操作的基本对象。在 C 语言中，把输入和输出设备都看作文件。</p><p><strong>文件一般包括三要素：</strong><code>文件路径</code>、<code>文件名</code>、<code>后缀</code>。</p><h3 id="1-1文件路径"><a href="#1-1文件路径" class="headerlink" title="1.1文件路径"></a>1.1文件路径</h3><blockquote><p>由于在 C 语言中<code>'\'</code> 一般是转义字符的起始标志，故在路径中需要用<code>两个 '\'</code> 表示路径中目录层次的间隔，也可以使用<code>'/'</code>作为路径中的分隔符。</p></blockquote><p>例如，”E:\ch10.doc”或者”E:/ch10.doc”，表示文件 ch10.doc 保存在 E 盘根目录下。”f1.txt” 表示当前目录下的文件 f1.txt。</p><p><strong>文件路径：</strong>可以显式指出其绝对路径，如上面的<code>”E:\\”</code>或者<code>”E:/”</code>等；如果没有显式指出其路径，默认为当前路径。<br>C 语言不仅支持对当前目录和根目录文件的操作，也支持对多级目录文件的操作，例如：</p><pre><code>D:\\C_WorkSpace\\Chapter_10\\file_1.txt</code></pre><p><strong>或者</strong></p><pre><code>D:/C_WorkSpace/Chapter_10/file_1.txt</code></pre><p>中的 file_1.txt 均是 C 语言可操作的多级目录文件。</p><h3 id="1-2文件名"><a href="#1-2文件名" class="headerlink" title="1.2文件名"></a>1.2文件名</h3><blockquote><p><strong>文件名：</strong>标识文件名字的合法标识符，如 ch10、file_1 等都是合法的文件名。</p></blockquote><p><strong>后缀：</strong>一般用于标明文件的类型，使用方式为：<code>文件名.后缀</code>，即文件名与后缀之间用<code>'.'</code> 隔开。常见的后缀类型有：<code>doc</code>、<code>txt</code>、<code>dat</code>、<code>c</code>、<code>cpp</code>、<code>obj</code>、<code>exe</code>、<code>bmp</code>、<code>jpg</code>、<code>png</code>、<code>js</code>、<code>html</code>、<code>pdf</code> 等。</p><h3 id="1-3文件结构"><a href="#1-3文件结构" class="headerlink" title="1.3文件结构"></a>1.3文件结构</h3><blockquote><p>文件按其逻辑结构可分为：<code>记录文件</code>和<code>流式文件</code>。而记录文件又可分为：<code>顺序文件</code>、<code>索引文件</code>、<code>索引顺序文件</code>及<code>散列文件</code>等。</p></blockquote><p>流式文件是以<code>字节</code>为单位，对流式文件的访问一般采用<code>穷举搜索</code>的方式，效率不高，故一般需频繁访问的较大数据不适宜采用流式文件逻辑结构。但由于流式文件<code>管理简单</code>，用户可以较方便地对文件进行相关操作。</p><h2 id="2-流的概念和分类"><a href="#2-流的概念和分类" class="headerlink" title="2.流的概念和分类"></a>2.流的概念和分类</h2><blockquote><p>I/O 设备的多样性及复杂性，给程序设计者访问这些设备带来了很大的难度和不便。为此，ANSIC 的 I/O 系统即标准 I/O 系统，把任意输入的源端或任意输出的终端，都抽象转换成了概念上的“标准 I/O 设备”或称“标准逻辑设备”。程序绕过具体设备，直接与该“标准逻辑设备”进行交互，这样就为程序设计者提供了一个不依赖于任何具体 I/O 设备的统一操作接口，<code>通常把抽象出来的“标准逻辑设备”或“标准文件”称作“流”</code>.</p></blockquote><h3 id="2-1流介绍"><a href="#2-1流介绍" class="headerlink" title="2.1流介绍"></a>2.1流介绍</h3><blockquote><p>把任意 I/O 设备，转换成逻辑意义上的“标准 I/O 设备”或“标准文件”的过程，并不需要程序设计者感知和处理，是由标准 I/O 系统自动转换完成的。故从这个意义上，可以认为任意输入的源端和任意输出的终端均对应一个“流”。</p></blockquote><p><strong>流按方向分为：</strong><code>输入流</code>和<code>输出流</code>。从文件获取数据的流称为输入流，向文件输出数据称为输出流。</p><p>例如，从键盘输入数据然后把该数据输出到屏幕上的过程，相当于从一个文件输入流（与键盘相关）中输入（读取）数据，然后通过另外一个文件输出流（与显示器相关）把获取的数据输出（写入）到文件（显示器）上。</p><p><strong>流按数据形式分为：</strong><code>文本流</code>和<code>二进制流</code>。文本流是ASCII 码<code>字符序列</code>，而二进制流是<code>字节序列</code>。</p><h3 id="2-2文本文件与二进制文件"><a href="#2-2文本文件与二进制文件" class="headerlink" title="2.2文本文件与二进制文件"></a>2.2文本文件与二进制文件</h3><ul><li><strong>文本文件：</strong>把要存储的数据当成一系列字符组成，把每个字符的 <code>ASCII 码值</code>存入文件中。每个 ASCII 码值占一个字节，每个字节表示一个字符。故文本文件也称作字符文件或 ASCII 文件，是<code>字符序列</code>文件。</li><li><strong>二进制文件：</strong>把数据对应的二进制形式存储到文件中，是<code>字节序列</code>文件。</li></ul><p>例如数据 123，如果按文本文件形式存储，把数据看成三个字符：’1’、’2’、’3’ 的集合，文件中依次存储各个字符的 <code>ASCII 码值</code>，格式如表 所示。</p><table><thead><tr><th>字符</th><th>‘1’</th><th>‘2’</th><th>‘3’</th></tr></thead><tbody><tr><td>ASCII(十进制)</td><td>49</td><td>50</td><td>51</td></tr><tr><td>ASCII(二进制)</td><td>0011 001</td><td>0011 0010</td><td>0011 0011</td></tr></tbody></table><p>如果按照二进制文件形式存储，则把数据 123 看成整型数，如果该系统中整型数占 4 个字节，则数据 123 二进制存储形式的 4 个字节如下。</p><pre class=" language-c"><code class="language-c"><span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0111</span> <span class="token number">1011</span></code></pre><h2 id="3-文件的打开与关闭"><a href="#3-文件的打开与关闭" class="headerlink" title="3.文件的打开与关闭"></a>3.文件的打开与关闭</h2><blockquote><p>C 程序中对任何文件进行操作，都必须先“打开”文件，即打开流；操作完成后，需“关闭”文件，即关闭流。可调用标准库 <code>stdio.h</code> 中的<code>fopen()</code> 和 <code>fclose()</code> 函数实现。</p></blockquote><p><strong>打开函数 fopen() 的原型如下</strong></p><pre class=" language-c"><code class="language-c">FILE <span class="token operator">*</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>函数参数：</strong></p><ul><li><code>filename</code>: 文件名，包括路径，如果不显式含有路径，则表示当前路径。例如，“D:\f1.txt”表示 D 盘根目录下的文件 f1.txt 文件。“f2.doc”表示当前目录下的文件 f2.doc。</li><li><code>mode</code>: 文件打开模式，指出对该文件可进行的操作。常见的打开模式如 “r” 表示只读，“w” 表示只写，“rw” 表示读写，“a” 表示追加写入。更多的打开模式请看下文。</li></ul><p><strong>返回值：</strong>打开成功，返回该文件对应的 FILE 类型的指针；打开失败，返回 NULL。故<code>需定义 FILE 类型的指针变量，保存该函数的返回值</code>。可根据该函数的返回值判断文件打开是否成功。</p><h3 id="打开模式"><a href="#打开模式" class="headerlink" title="打开模式"></a>打开模式</h3><blockquote><p>在C语言的文件操作语法中，打开文件文件有以下12种模式，如下图： </p></blockquote><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-2zr8{background-color:#009901;border-color:#000000;text-align:center;vertical-align:middle}.tg .tg-hgci{color:#6200c9;border-color:#000000;text-align:center;vertical-align:middle}.tg .tg-p57i{background-color:#ffce93;color:#fe0000;border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-mcug{background-color:#68cbd0;border-color:#000000;text-align:center;vertical-align:middle}.tg .tg-erxi{color:#6200c9;border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-du2d{color:#009901;border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-i218{color:#009901;text-align:center;vertical-align:top}</style><table class="tg">  <tbody><tr>    <th class="tg-mcug">打开模式</th>    <th class="tg-mcug">只可读</th>    <th class="tg-mcug" colspan="2">只可写</th>    <th class="tg-2zr8" colspan="3">读写皆可</th>  </tr>  <tr>    <td class="tg-p57i">文本模式</td>    <td class="tg-erxi">r</td>    <td class="tg-erxi">w </td>    <td class="tg-hgci">a</td>    <td class="tg-du2d">r+</td>    <td class="tg-du2d">w+</td>    <td class="tg-i218">a+</td>  </tr>  <tr>    <td class="tg-p57i">二进制模式</td>    <td class="tg-erxi">rb</td>    <td class="tg-erxi">wb</td>    <td class="tg-erxi">ab</td>    <td class="tg-du2d">rb+或r+b</td>    <td class="tg-du2d">wb或w+b</td>    <td class="tg-i218">ab+或a+b</td>  </tr></tbody></table><blockquote><p>其中，<code>二进制模式</code>与<code>文本模式</code>操作相似，只不过是以二进制流的形式读写而已，下面以<code>文本模式为例</code>分析：</p></blockquote><ol><li><p><strong>“r” 模式：</strong></p><ul><li>打开文件进行<code>“只读”</code>操作，即只能从文件读取内容。</li><li>若欲操作的<code>文件不存在，则打开失败</code>。</li><li>成功打开文件时，文件指针位于<code>文件开头</code>。</li><li>打开文件后，<code>不会清空</code>文件内原有内容。</li><li>可从文件中<code>任意位置</code>读取内容。</li></ul></li><li><p><strong>“w” 模式：</strong></p><ul><li>打开文件进行<code>“只写”</code>操作，即只能向文件写入内容。</li><li>若欲操作的<code>文件不存在，则新建文件</code>。</li><li>成功打开文件时，文件指针位于文件<code>开头</code>。</li><li>打开文件后，<code>会清空文件</code>内原有的内容。</li><li>可向文件中<code>任意位置</code>写入内容，且进行写入操作时，<code>会覆盖原有位置的内容</code>。</li></ul></li><li><p><strong>“a” 模式：</strong></p><ul><li>打开文件进行<code>“追加”</code>操作，即只能向文件写入内容。</li><li>若欲操作的<code>文件不存在，则新建文件</code>。</li><li>成功打开文件时，文件指针位于<code>文件结尾</code>。</li><li>打开文件后，<code>不会清空</code>文件内原有内容。</li><li>只能向文件<code>末尾追加</code>(写)内容。</li></ul></li><li><p><strong>“r+”模式：</strong></p><ul><li>打开文件进行<code>“读写”</code>操作，即既可读取，又可写入。</li><li>若欲操作的<code>文件不存在，则打开失败</code>。</li><li>成功打开文件时，文件指针位于<code>文件开头</code>。</li><li>打开文件后，<code>不会清空</code>文件内原有内容。</li><li>无论是读取内容还是写入内容，都可在文件中<code>任意位置</code>进行，且进行写入操作时，<code>会覆盖原有位置的内容</code>。</li></ul></li><li><p><strong>“w+”模式：</strong></p><ul><li>打开文件进行<code>“读写”</code>操作，即既可读取，又可写入。</li><li>若欲操作的<code>文件不存在，则新建文件</code>。</li><li>成功打开文件时，文件指针位于<code>文件开头</code>。</li><li>打开文件后，<code>会清空文件</code>内原有的内容。</li><li>无论是读取内容还是写入内容，都可在文件中任意位置进行，且进行写入操作时，会覆盖原有位置的内容。</li></ul></li><li><p><strong>“a+”模式：</strong></p><ul><li>打开文件进行<code>“读写”</code>操作，即既可读取，又可写入。</li><li>若欲操作的<code>文件不存在，则新建文件</code>。</li><li>成功打开文件时，文件指针位于<code>文件结尾</code>。</li><li>打开文件后，<code>不会清空</code>文件内原有内容。</li><li>读取内容时，可以在<code>任意位置</code>进行，但写入内容时，只会<code>追加在文件尾部</code>。</li></ul></li></ol><p><code>不同的打开模式对应不同的操作方式，使用时需仔细规划。</code></p><p><strong>关闭函数 fclose 的原型如下。</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fclose</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>函数参数：</strong>fp:已打开的文件指针。</p><p><strong>返回值：</strong>正常关闭，返回否则返回 EOF(-1)。<br><strong>示例</strong></p><pre class=" language-c"><code class="language-c">FILE fpl<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span>”D<span class="token punctuation">:</span>\\fl<span class="token punctuation">.</span>txt”，”r”）<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//以只读模式打开文件 fl.txt</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>fpl<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//以返回值fpl判断是否打开成功，如果为NULL表示失败</span><span class="token punctuation">{</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Failed to open the file !\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//终止程序，stdlib .h头文件中</span><span class="token punctuation">}</span>FILE fp2<span class="token operator">=</span><span class="token function">fopen</span> <span class="token punctuation">(</span><span class="token string">"f2.txt"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//以追加写入的模式打开文件f2 .txt</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>fp2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Failed to open the file !\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fclose</span> <span class="token punctuation">(</span>fpl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关闭fpl指针对应文件（fl.txt)的流</span><span class="token function">fclose</span> <span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关闭fp2指针对应文件（f2.txt)的流</span></code></pre><h2 id="关于换行符"><a href="#关于换行符" class="headerlink" title="关于换行符"></a>关于换行符</h2><blockquote><p>我们知道在UNIX下是没有回车符（\r）的，只有换行符（\n），而C语言诞生于UNIX（Linux即面向开源的UNIX，Mac OS也是UNIX发展而来的，而Windows是从MS-DOS发展而来，与前两者不同），所以C语言的源代码文件中也是以 \n 表示换行。</p><blockquote><ul><li><code>回车'\r'</code>:表示光标回到该行的行首处。</li><li><code>换行'\n'</code>:表示光标从当前行该列位置移动到下一行对应的该列位置。</li></ul></blockquote></blockquote><p>所以总结一下：</p><p>Windows下换行采用 \r\n 表示，全称回车换行符。</p><p>UNIX（Linux）下换行采用 \n 表示，即换行符。</p><p>Mac OS下换行采用 \r 表示，即回车符。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scanf()和printf()函数详解</title>
      <link href="/2019/09/20/scanf-he-printf-han-shu-xiang-jie/"/>
      <url>/2019/09/20/scanf-he-printf-han-shu-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="1-printf-简介"><a href="#1-printf-简介" class="headerlink" title="1.printf()简介"></a>1.printf()简介</h2><blockquote><p>printf() 是 C 语言标准库函数，用于将格式化后的字符串输出到标准输出。标准输出，即标准输出文件，对应终端的屏幕。printf() 申明于头文件 stdio.h。</p></blockquote><p><strong>函数原型</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">printf</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>返回值</strong></p><blockquote><p>正确返回输出的字符总数，错误返回负值。与此同时，输入输出流错误标志将被置值，可由指示器函数 ferror(FILE *stream) 来检查输入输出流的错误标志，如果 ferror() 返回一个非零值，表示出错。</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>输出结果</code><br>Hello World!<br>13<br><strong>调用格式</strong></p><blockquote><p>字符串常量原样输出，在显示中起提示作用。输出表列中给出了各个输出项，要求格式控制字符串和各输出项在数量和类型上应该一一对应。其中格式控制字符串是以 % 开头的字符串，在 % 后面跟有各种格式控制符，以说明输出数据的类型、宽度、精度等。</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"格式化字符串"</span><span class="token punctuation">,</span> 输出表列<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span>prec<span class="token punctuation">]</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span>type<span class="token operator">%</span><span class="token punctuation">[</span>标志<span class="token punctuation">]</span><span class="token punctuation">[</span>最小宽度<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span>精度<span class="token punctuation">]</span><span class="token punctuation">[</span>类型长度<span class="token punctuation">]</span>类型</code></pre><h3 id="1-1-类型-type"><a href="#1-1-类型-type" class="headerlink" title="1.1 类型(type)"></a>1.1 类型(type)</h3><blockquote><p>首先说明类型，因为类型是格式控制字符串的重中之重，是必不可少的组成部分，其它的选项都是可选的。type 用于规定输出数据的类型，含义如下：</p></blockquote><table><thead><tr><th align="center">字符</th><th align="center">对应数据类型</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td align="center">d/i</td><td align="center">int</td><td>输出十进制有符号32bits整数，i是老式写法</td><td><code>printf("%i",123);</code>输出123</td></tr><tr><td align="center">o</td><td align="center">unsigned int</td><td>无符号8进制(octal)整数(不输出前缀0)</td><td><code>printf("0%o",123);</code>输出0173</td></tr><tr><td align="center">u</td><td align="center">unsigned int</td><td>无符号10进制整数</td><td><code>printf("%u",123);</code>输出123</td></tr><tr><td align="center">x/X</td><td align="center">unsigned int</td><td>无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF（不输出前缀0x)</td><td><code>printf("0x%x 0x%X",123,123);</code>输出0x7b 0x7B</td></tr><tr><td align="center">f/lf</td><td align="center">float(double)</td><td>单精度浮点数用f,双精度浮点数用lf(printf可混用，但scanf不能混用)</td><td><code>printf("%.9f %.9lf",0.000000123,0.000000123);</code>输出0.000000123 0.000000123。注意指定精度，否则printf默认精确到小数点后六位</td></tr><tr><td align="center">F</td><td align="center">float(double)</td><td>与f格式相同，只不过 infinity 和 nan 输出为大写形式。</td><td>例如<code>printf("%f %F %f %F\n",INFINITY,INFINITY,NAN,NAN);</code>输出结果为inf INF nan NAN</td></tr><tr><td align="center">e/E</td><td align="center">float(double)</td><td>科学计数法，使用指数(Exponent)表示浮点数，此处”e”的大小写代表在输出时“e”的大小写</td><td><code>printf("%e %E",0.000000123,0.000000123);</code>输出1.230000e-07 1.230000E-07</td></tr><tr><td align="center">g</td><td align="center">float(double)</td><td>根据数值的长度，选择以最短的方式输出，%f或%e</td><td><code>printf("%g %g",0.000000123,0.123);</code>输出1.23e-07 0.123</td></tr><tr><td align="center">G</td><td align="center">float(double)</td><td>根据数值的长度，选择以最短的方式输出，%f或%E</td><td><code>printf("%G %G",0.000000123,0.123);</code>输出1.23E-07 0.123</td></tr><tr><td align="center">c</td><td align="center">char</td><td>字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</td><td><code>printf("%c\n",64);</code>输出A</td></tr><tr><td align="center">s</td><td align="center">char*</td><td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以空字符’\0‘结尾）</td><td><code>printf("%s","测试test");</code>输出：测试test</td></tr><tr><td align="center">S</td><td align="center">wchar_t*</td><td>宽字符串。输出字符串中的字符直至字符串中的空字符（宽字符串以两个空字符’\0‘结尾）</td><td><code>setlocale(LC_ALL,"zh_CN.UTF-8");wchar_t wtest[]=L</code>“测试Test”;<code>printf("%S\n",wtest);</code>==输出：测试test==</td></tr><tr><td align="center">p</td><td align="center">void*</td><td>以16进制形式输出指针</td><td><code>printf("0x%p","lvlv");</code>输出：0x000000013FF73350</td></tr><tr><td align="center">n</td><td align="center">int*</td><td>什么也不输出。%n对应的参数是一个指向signed int的指针，在此之前输出的字符数将存储到指针所指的位置    int num=0;</td><td><code>printf("lvlv%n",&amp;num);printf("num:%d",num);</code>==输出:lvlvnum:4==</td></tr><tr><td align="center">%</td><td align="center">字符%</td><td>输出字符‘%’（百分号）本身</td><td><code>printf("%%");</code>    输出:%</td></tr><tr><td align="center">m</td><td align="center">无</td><td>打印errno值对应的出错内容</td><td><code>printf("%m\n");</code></td></tr><tr><td align="center">a/A</td><td align="center">float(double)</td><td>十六进制p计数法输出浮点数，a为小写，A为大写</td><td><code>printf("%a %A",15.15,15.15);</code>输出：0x1.e4ccccccccccdp+3 0X1.E4CCCCCCCCCCDP+3</td></tr></tbody></table><p><strong>注意</strong></p><ol><li>使用 printf() 输出宽字符时，需要使用 setlocale 指定本地化信息并同时指明当前代码的编码方式。除了使用 %S，还可以使用 %ls。</li><li>%a 和 %A 是 C99 引入的格式化类型，采用十六进制 p 计数法输出浮点数。p 计数法类似 E 科学计数法，但有所不同。数以 0x 开头，然后是 16 进制浮点数部分，接着是 p 后面是以 2 为底的阶码。以上面输出的 15.15 为例，推算输出结果。15.15 转换成二进制为<code>1111.00 1001 1001 1001 1001 ...</code>，因为二进制表示数值的离散特点，计算机对于小数有时是不能精确表示的，比如 0.5 可以精确表示为1<sub>2</sub>，而 0.15 却不能精确表示。将15.15 对应的二进制右移三位，为<code>1.1110 0100 1100 1100 1100 ...</code>转换对应的十六进制就是<code>0x1.e4ccccccccccd</code>，注意舍入时向高位进了1位。由于右移三位，所以二进制阶码是 3。最后的结果就是 <code>0x1.e4ccccccccccdp+3</code>。</li><li>格式控制字符串除了指明输出的数据类型，还可以包含一些其它的可选的格式说明，依序有 flags, width, .precision and length。下面一一讲解.</li></ol><h3 id="1-2-标志（flags）"><a href="#1-2-标志（flags）" class="headerlink" title="1.2 标志（flags）"></a>1.2 标志（flags）</h3><blockquote><p>flags 规定输出样式，取值和含义如下:</p></blockquote><table><thead><tr><th align="center">字符</th><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">减号</td><td align="center">结果左对齐，右边填空格。默认是右对齐，左边填空格。</td></tr><tr><td align="center">+</td><td align="center">加号</td><td align="center">输出符号(正号或负号)</td></tr><tr><td align="center">space</td><td align="center">空格</td><td align="center">输出值为正时加上空格，为负时加上负号</td></tr><tr><td align="center">#</td><td align="center">井号</td><td align="center">type是o、x、X时，增加前缀0、0x、0X。==type是a、A、e、E、f、g、G时，<code>一定使用小数点</code>。默认的，如果使用.0控制不输出小数部分，则不输出小数点。type是g、G时，尾部的0保留。==</td></tr><tr><td align="center">0</td><td align="center">数字零</td><td align="center">将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用“-”）</td></tr></tbody></table><blockquote><p>示例:</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%5d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//默认右对齐,左边补空格</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-5d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//左对齐,右边补空格</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%+d %+d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出正负号</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"% d % d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//正号用空格替代，负号输出</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x %#x\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出0x</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.0f %#.0f\n"</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//当小数点后不输出值时依然输出小数点</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%g %#g\n"</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">,</span><span class="token number">1000.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//保留小数点后后的0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%05d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//前面补0</span></code></pre><p><strong>结果</strong></p><pre class=" language-c"><code class="language-c"> <span class="token number">1000</span><span class="token number">1000</span> <span class="token operator">+</span><span class="token number">1000</span> <span class="token operator">-</span><span class="token number">1000</span> <span class="token number">1000</span> <span class="token operator">-</span><span class="token number">1000</span><span class="token number">3e8</span> <span class="token number">0x3e8</span><span class="token number">1000</span> <span class="token number">1000</span><span class="token punctuation">.</span><span class="token number">1000</span> <span class="token number">1000.0</span><span class="token number">01000</span></code></pre><h3 id="1-3-输出最小宽度（width）"><a href="#1-3-输出最小宽度（width）" class="headerlink" title="1.3 输出最小宽度（width）"></a>1.3 输出最小宽度（width）</h3><blockquote><p>用十进制整数来表示输出的最少位数。若实际位数多于指定的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。width的可能取值如下：</p></blockquote><table><thead><tr><th align="center">width</th><th align="center">描述</th><th>示例</th></tr></thead><tbody><tr><td align="center">数值</td><td align="center">十进制整数</td><td><code>printf("%06d",1000);</code>输出:001000</td></tr><tr><td align="center">*</td><td align="center">星号</td><td>不显示指明输出最小宽度，而是以星号代替，在printf的输出参数列表中给出</td></tr></tbody></table><h3 id="1-4-精度（-precision）"><a href="#1-4-精度（-precision）" class="headerlink" title="1.4 精度（.precision）"></a>1.4 精度（.precision）</h3><blockquote><p>精度格式符以<code>“.”</code>开头，后跟十进制整数。可取值如下：</p></blockquote><table><thead><tr><th align="center">.precision</th><th>描述</th></tr></thead><tbody><tr><td align="center">.数值</td><td>十进制整数。<br>(1)对于整型（d,i,o,u,x,X）,precision表示输出的最小的数字个数，不足补前导零，超过不截断。<br> (2)对于浮点型（a, A, e, E, f ），precision表示小数点后数值位数，默认为六位，不足补后置0，超过则截断。<br>(3)对于类型说明符g或G，表示可输出的最大有效数字。<br>(4)对于字符串（s），precision表示最大可输出字符数，不足正常输出，超过则截断。<br><code>precision不显示指定，则默认为0</code></td></tr><tr><td align="center">.*</td><td>以星号代替数值，类似于width中的*，在输出参数列表中指定精度。</td></tr></tbody></table><p><strong>示例:</strong></p><pre class=" language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8d\n"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//不足指定宽度补前导0，效果等同于%08d</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8f\n"</span><span class="token punctuation">,</span><span class="token number">1000.123456789</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//超过精度，截断</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8f\n"</span><span class="token punctuation">,</span><span class="token number">1000.123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不足精度，补后置0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8g\n"</span><span class="token punctuation">,</span><span class="token number">1000.123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//最大有效数字为8位</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8s\n"</span><span class="token punctuation">,</span>“abcdefghij”<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//超过指定长度截断</span></code></pre><p><strong>结果</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">00001000</span><span class="token number">1000.12345679</span><span class="token number">1000.12345600</span><span class="token number">1000.1235</span>abcdefgh</code></pre><p><strong>注意:</strong><code>在对浮点数和整数截断时，存在四舍五入。</code></p><h3 id="1-5-类型长度（length）"><a href="#1-5-类型长度（length）" class="headerlink" title="1.5 类型长度（length）"></a>1.5 类型长度（length）</h3><blockquote><p>类型长度指明待输出数据的长度。因为相同类型可以有不同的长度，比如整型有 16bits 的 short int，32bits的int，也有 64bits 的 long int，浮点型有32bits的单精度 float 和 64bits 的双精度 double。为了指明同一类型的不同长度，于是乎，类型长度（length）应运而生，成为格式控制字符串的一部分。</p></blockquote><table><thead><tr><th align="center">符号</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">hh</td><td align="center">与d、i 一起使用，表示一个signed char 类型的值；与o、u、x、X—起使用，表示一个unsigned char 类型的值；与 n 一起使用，表示相应的变元是指向 signed char 型变量的指针（c99 )</td></tr><tr><td align="center">h</td><td align="center">与d、i、o、u、x、X 或 n 一起使用，表示一个short int 或 unsigned short int 类型的值</td></tr><tr><td align="center">l</td><td align="center">与d、i、o、u、x、X 或 n 一起使用，表示一个 long int 或者 unsigned long int 类型的值</td></tr><tr><td align="center">ll</td><td align="center">与 d、i、o、u、x、X 或 n —起使用，表示相应的变元是 long long int 或 unsigned long long int 类型的值(c99 )</td></tr><tr><td align="center">j</td><td align="center">与 d、i、o、u、x、X 或 n —起使用，表示匹配的变元是 intmax_t 或 uintmax_t 类型，这些类型在“stdint. h”中声明（c99 )</td></tr><tr><td align="center">z</td><td align="center">与 d、i、o、u、x、X 或 n —起使用，表示匹配的变元是指向 size_t 类型对象的指针，该类型在“stddef. h”中声明(c99 )</td></tr><tr><td align="center">t</td><td align="center">与d、i、o、u、x、X 或 n —起使用，表示匹配的变元是指向 ptrdiff_t 类型对象的指针，该类型在“stddef. h”中声明(c99 )</td></tr><tr><td align="center">L</td><td align="center">和a、A、e、E、f、F、g、G—起使用，表示一个long double类型的值</td></tr></tbody></table><p><strong>注意:</strong></p><ul><li>long int到底是32bits还是64bits跟生成的程序是32bits还是64bits一一对应，如果使用g++编译程序的话，可通过<code>-m32</code>或<code>-m64</code>选项分别生成32bits和64bits的程序</li></ul><ul><li>除此之外，每一个输出参数的输出格式都必须有对应的格式说明符与之一一对应，并且类型必须匹配。若二者不能够一一对应匹配，则不能够正确输出，而且编译时可能不会报错。</li><li>同时，若格式说明符个数少于输出项个数，则多余的输出项将不予输出；若格式说明符个数多于输出项个数，则可能会输出一些毫无意义的数字乱码。</li></ul><h2 id="2-scanf-简介"><a href="#2-scanf-简介" class="headerlink" title="2.scanf()简介"></a>2.scanf()简介</h2><blockquote><p>相对于 printf 函数，scanf 函数就简单得多。scanf 函数的功能与 printf 函数正好相反，执行格式化输入功能。即 scanf 函数从格式串的最左端开始，每遇到一个字符便将其与下一个输入字符进行“匹配”，如果二者匹配（相同）则继续，否则结束对后面输入的处理。而每遇到一个格式说明符，便按该格式说明符所描述的格式对其后的输入值进行转换，然后将其存于与其对应的输入地址中.</p></blockquote><p><strong>函数原型</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">printf</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>返回值</strong></p><blockquote><p>当格式化字符串format到达末尾或者读取的输入不再匹配格式字符串所指定的类型时，输入就停止，并返回被转换的输入值的数目,若在任何输入都没被转换之前文件就到达尾部则返回EOF。</p></blockquote><p><strong>示例</strong></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    num<span class="token operator">=</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输入:<br>1 2 3<br>徐南木<br><strong>结果</strong></p><pre><code>1 2 33徐南木1</code></pre><p><strong>调用格式</strong></p><blockquote><p>由于scanf是采用可变参数的机制，所以函数无法验证它们的指针参数是否为正确的类型，所以函数假定它们是正确的，（因此格式字符必须和后面的指针指向的类型保持一致）如果指针参数的类型和输入数据的类型不匹配则结果值就是垃圾。而且邻近的变量也有可能被改写</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"格式化字符串"</span><span class="token punctuation">,</span> 输入表列<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span> type_char<span class="token operator">%</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">[</span>宽度<span class="token punctuation">]</span><span class="token punctuation">[</span>长度<span class="token punctuation">]</span>类型符</code></pre><p><strong>提示:</strong>数据类型和格式输入可参考<code>printf()</code>函数.</p><h3 id="2-1-捕获规则"><a href="#2-1-捕获规则" class="headerlink" title="2.1 捕获规则"></a>2.1 捕获规则</h3><blockquote><p>在出现一个转换说明符时，scanf函数会忽略前面的所有空白字符（除了%c），然后再捕获相应的数据类型，一直到最大长度或者出现空白字符</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p><code>允许的输入格式为：1,2\n；1,  2\n；1,\n2\n；</code><br><code>不允许的输入格式：1 ,2\n；   \n1,2\n； 1,2\n；</code>  </p><h3 id="2-2-scanf-中的空格和-n"><a href="#2-2-scanf-中的空格和-n" class="headerlink" title="2.2 scanf()中的空格和\n"></a>2.2 scanf()中的空格和\n</h3><blockquote><p>scanf中的空格的作用不仅仅是捕获一个空格，它表示捕获所有空白字符（空格，换行，制表符等）直到出现一个非空白字符（\n一样），例如</p></blockquote><p>我们想接受一个ip:端口的输入<br>需要接受的输入格式为：<code>ip:端口</code>，<code>ip: 端口</code>，<code>ip : 端口</code>，<code>ip\n:\n端口</code><br>如果代码为</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d.%d.%d.%d:%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>`</code></pre><p>则只能捕获的格式：<code>ip:端口</code>，<code>ip: 端口</code>，<code>ip:\n端口</code>;<br>如果我们将代码改为</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d.%d.%d.%d :%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>:</code>前面多了一个空格,则可以捕获上述所有情况.</p><h3 id="2-3-正则表达"><a href="#2-3-正则表达" class="headerlink" title="2.3 正则表达"></a>2.3 正则表达</h3><blockquote><p>scanf()函数正则表达严格意义上不是,只能算伪正则表达且只能用于<code>string</code></p><blockquote><ul><li>[]内是匹配的字符,^表示求反集，当遇到非集合内的字符时立即终止输入</li><li>%表示选择，%后面的是条件</li><li>%* 与%刚好相反，表示过滤满足条件的字符，也就是跳过满足条件的字符，其后一定要有新的%语句，否则无法读入</li></ul></blockquote></blockquote><ol><li><p>输入指定范围的小写字母，遇到非法字符立即终止</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-z]"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入：xunanmu123<br>输出:<code>xunamu</code></p></li><li><p>获取指定范围的小写字母和数字</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-z0-9]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>​<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入：xunanmu123<br>输出：<code>xunanmu123</code></p></li><li><p>获取带空格的自定范围的字符串</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-z A-Z0-9]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入：123xu nan mu Blog<br>输出:<code>123xu nan mu Blog</code></p></li><li><p>输入<code>不带</code>空格的自定范围的字符串</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[a-zA-Z0-9]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入：123xu nan mu Blog<br>输出:<code>123xu</code></p></li></ol><p><strong>注意:scanf()字符串默认空格结束</strong></p><ol start="5"><li>获取不包括指定字符的字符<pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[^a-z]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>输入：23 徐南木 BLOG Aabc<br>输出：<code>23 徐南木 BLOG A</code></li></ol><p><strong>注意：这种方式可以读入空格</strong></p><ol start="6"><li><p>获取一整行字符串，包括空格</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%[^\n]"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入：23 徐南木 BLOG Aabc<br>输出：<code>23 徐南木 BLOG Aabc</code></p></li><li><p>%* 跳过指定范围的字符再读取指定范围的字符</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%*[a-z0-9]%[^\n]"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输入: abc 徐南木  xnm<br>输出:<code>徐南木 xnm</code></p></li><li><p>找了俩道经典的<code>%*``%</code>匹配<br>例1：从<a href="sip:tom@172.18.1.133" target="_blank" rel="noopener">sip:tom@172.18.1.133</a>中提取tom</p><pre class=" language-c"><code class="language-c"> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> url <span class="token operator">=</span> <span class="token string">"&lt;sip:tom@172.18.1.133>"</span><span class="token punctuation">;</span> <span class="token keyword">char</span> uri<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">sscanf</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token string">"%*[^:]:%[^@]"</span><span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>例2：从iios/12DDWDFF@122中提取12DDWDFF</p><pre class=" language-c"><code class="language-c"> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s <span class="token operator">=</span> <span class="token string">"iios/12DDWDFF@122"</span><span class="token punctuation">;</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">sscanf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"%*[^/]/%[^@]"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h2 id="3-转义字符"><a href="#3-转义字符" class="headerlink" title="3.转义字符"></a>3.转义字符</h2><blockquote><p>转义字符在字符串中会被自动转换为相应操作命令。printf()使用的常见转义字符如下：</p></blockquote><table><thead><tr><th align="center">转义字符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">\a</td><td align="center">警报(响铃)符</td></tr><tr><td align="center">\b</td><td align="center">回退符</td></tr><tr><td align="center">\f</td><td align="center">换页符</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\r</td><td align="center">回车符</td></tr><tr><td align="center">\t</td><td align="center">横向制表符</td></tr><tr><td align="center">\v</td><td align="center">纵向制表符</td></tr><tr><td align="center">\</td><td align="center">反斜杠</td></tr><tr><td align="center">“</td><td align="center">双引号</td></tr></tbody></table><h2 id="4-关于缓冲区"><a href="#4-关于缓冲区" class="headerlink" title="4.关于缓冲区"></a>4.关于缓冲区</h2><h3 id="4-1-关于printf缓冲"><a href="#4-1-关于printf缓冲" class="headerlink" title="4.1 关于printf缓冲"></a>4.1 关于printf缓冲</h3><blockquote><p>在 printf 的实现中，在调用 write 之前先写入 IO 缓冲区，这是一个用户空间的缓冲。系统调用是软中断，频繁调用，需要频繁陷入内核态，这样的效率不是很高，而 printf 实际是向用户空间的 IO 缓冲写，在满足条件的情况下才会调用 write 系统调用，减少IO次数，提高效率。<br>printf 在 <code>glibc</code>    中默认为行缓冲，遇到以下几种情况会刷新缓冲区，输出内容：</p></blockquote><ul><li>（1）缓冲区填满；</li><li>（2）写入的字符中有换行符\n或回车符\r；</li><li>（3）调用<code>fflush</code>手动刷新缓冲区；</li><li>（4）调用scanf要从输入缓冲区中读取数据时，也会将输出缓冲区内的数据刷新。<br>可使用<code>setbuf(stdout,NULL)</code>关闭行缓冲，或者<code>setbuf(stdout,uBuff)</code>设置新的缓冲区，uBuff为自己指定的缓冲区。也可以使用<code>setvbuf(stdout,NULL,_IOFBF,0)</code>;来改变标准输出为全缓冲。全缓冲与行缓冲的区别在于遇到换行符不刷新缓冲区。</li></ul><p><code>printf 在 VC++ 中默认关闭缓冲区，输出时会及时的输到屏幕。如果显示开启缓冲区，只能设置全缓冲.</code></p><h3 id="4-2-关于scanf缓冲"><a href="#4-2-关于scanf缓冲" class="headerlink" title="4.2 关于scanf缓冲"></a>4.2 关于scanf缓冲</h3><blockquote><p>在使用 scanf 函数的时候，需要特别注意的就是缓冲区问题。对 scanf 函数来说，估计最容易出错、最令人捉摸不透的问题应该是缓冲区问题了。</p><blockquote></blockquote><ul><li>标准输入缓冲区 stdin 使用行缓冲的方式存储输入。用户的输入数据首先被暂存在临时缓冲区中，当用户键入回车键或临时缓冲区满后，stdin 才进行 I/O 操作，将数据由临时缓冲区拷贝至 stdin 中。C语言提供的输入输出函数如 scanf 、getchar 等则从上述缓冲区 stdin 中读取数据输入。</li></ul></blockquote><p>　　scanf 和 getchar 等函数会在<code>stdin</code> 中读取数据，若上述缓冲区中已存在数据，则直接读取其中的数据，若上述缓冲区为空，则上述函数会挂起，等待数据缓冲的完成( 用户输入回车键或数据缓冲区满后， stdin 会进行数据缓冲，之后上述函数才能继续执行)。 用户一次输入的数据可能会超过 scanf 、getchar 等函数调用所需要的数据，那么所需数据被读取后，剩余的数据仍会存放在缓冲区中，之后的函数调用会直接读取 stdin 中已有的数据。只有当缓冲区为空后，scanf 等函数才会等待用户输入,实际应该是等待<code>stdin</code>的缓冲。<br><strong>解决办法</strong></p><ol><li>最简单就是在scanf()函数扫描前留空格.<pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">" %c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>可以使用 <code>fflush()</code> 函数清理缓冲区。C标准规定 fflush()函数可用来刷新输出（stdout）缓冲区(一般是将缓冲区数据写回存储设备)。但对于标准输入（stdin）则没有明确定义。部分编译器定义了 fflush( stdin )的实现，如微软的VC。也就是不同的编译器对于 fflush( stdin )的支持可能不同。<code>GCC编译器没有定义它的实现，所以不能使用 fflush( stdin )来刷新输入缓冲区。</code></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> 正则表达 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
